// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rslam.proto

#ifndef PROTOBUF_rslam_2eproto__INCLUDED
#define PROTOBUF_rslam_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "FrameObject.pb.h"
#include "CameraModel.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rslam_2eproto();
void protobuf_AssignDesc_rslam_2eproto();
void protobuf_ShutdownFile_rslam_2eproto();

class SessionIdMsg;
class ReferenceFrameIdMsg;
class TransformEdgeIdMsg;
class LandmarkIdMsg;
class MeasurementIdMsg;
class PixelMsg;
class PatchHomographyMsg;
class MeasurementMsg;
class MultiViewMeasurementMsg;
class LandmarkMsg;
class TransformEdgeMsg;
class ReferenceFrameMsg;
class CameraRigMsg;
class SlamMapMsg;

// ===================================================================

class SessionIdMsg : public ::google::protobuf::Message {
 public:
  SessionIdMsg();
  virtual ~SessionIdMsg();

  SessionIdMsg(const SessionIdMsg& from);

  inline SessionIdMsg& operator=(const SessionIdMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionIdMsg& default_instance();

  void Swap(SessionIdMsg* other);

  // implements Message ----------------------------------------------

  SessionIdMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionIdMsg& from);
  void MergeFrom(const SessionIdMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:pb.SessionIdMsg)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static SessionIdMsg* default_instance_;
};
// -------------------------------------------------------------------

class ReferenceFrameIdMsg : public ::google::protobuf::Message {
 public:
  ReferenceFrameIdMsg();
  virtual ~ReferenceFrameIdMsg();

  ReferenceFrameIdMsg(const ReferenceFrameIdMsg& from);

  inline ReferenceFrameIdMsg& operator=(const ReferenceFrameIdMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceFrameIdMsg& default_instance();

  void Swap(ReferenceFrameIdMsg* other);

  // implements Message ----------------------------------------------

  ReferenceFrameIdMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReferenceFrameIdMsg& from);
  void MergeFrom(const ReferenceFrameIdMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 frame_id = 1;
  inline bool has_frame_id() const;
  inline void clear_frame_id();
  static const int kFrameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 frame_id() const;
  inline void set_frame_id(::google::protobuf::uint32 value);

  // optional .pb.SessionIdMsg session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::pb::SessionIdMsg& session_id() const;
  inline ::pb::SessionIdMsg* mutable_session_id();
  inline ::pb::SessionIdMsg* release_session_id();
  inline void set_allocated_session_id(::pb::SessionIdMsg* session_id);

  // @@protoc_insertion_point(class_scope:pb.ReferenceFrameIdMsg)
 private:
  inline void set_has_frame_id();
  inline void clear_has_frame_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::SessionIdMsg* session_id_;
  ::google::protobuf::uint32 frame_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static ReferenceFrameIdMsg* default_instance_;
};
// -------------------------------------------------------------------

class TransformEdgeIdMsg : public ::google::protobuf::Message {
 public:
  TransformEdgeIdMsg();
  virtual ~TransformEdgeIdMsg();

  TransformEdgeIdMsg(const TransformEdgeIdMsg& from);

  inline TransformEdgeIdMsg& operator=(const TransformEdgeIdMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransformEdgeIdMsg& default_instance();

  void Swap(TransformEdgeIdMsg* other);

  // implements Message ----------------------------------------------

  TransformEdgeIdMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransformEdgeIdMsg& from);
  void MergeFrom(const TransformEdgeIdMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 edge_id = 1;
  inline bool has_edge_id() const;
  inline void clear_edge_id();
  static const int kEdgeIdFieldNumber = 1;
  inline ::google::protobuf::int32 edge_id() const;
  inline void set_edge_id(::google::protobuf::int32 value);

  // optional .pb.SessionIdMsg session_id = 2;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  inline const ::pb::SessionIdMsg& session_id() const;
  inline ::pb::SessionIdMsg* mutable_session_id();
  inline ::pb::SessionIdMsg* release_session_id();
  inline void set_allocated_session_id(::pb::SessionIdMsg* session_id);

  // optional .pb.ReferenceFrameIdMsg start = 3;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 3;
  inline const ::pb::ReferenceFrameIdMsg& start() const;
  inline ::pb::ReferenceFrameIdMsg* mutable_start();
  inline ::pb::ReferenceFrameIdMsg* release_start();
  inline void set_allocated_start(::pb::ReferenceFrameIdMsg* start);

  // optional .pb.ReferenceFrameIdMsg end = 4;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 4;
  inline const ::pb::ReferenceFrameIdMsg& end() const;
  inline ::pb::ReferenceFrameIdMsg* mutable_end();
  inline ::pb::ReferenceFrameIdMsg* release_end();
  inline void set_allocated_end(::pb::ReferenceFrameIdMsg* end);

  // @@protoc_insertion_point(class_scope:pb.TransformEdgeIdMsg)
 private:
  inline void set_has_edge_id();
  inline void clear_has_edge_id();
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::SessionIdMsg* session_id_;
  ::pb::ReferenceFrameIdMsg* start_;
  ::pb::ReferenceFrameIdMsg* end_;
  ::google::protobuf::int32 edge_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static TransformEdgeIdMsg* default_instance_;
};
// -------------------------------------------------------------------

class LandmarkIdMsg : public ::google::protobuf::Message {
 public:
  LandmarkIdMsg();
  virtual ~LandmarkIdMsg();

  LandmarkIdMsg(const LandmarkIdMsg& from);

  inline LandmarkIdMsg& operator=(const LandmarkIdMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LandmarkIdMsg& default_instance();

  void Swap(LandmarkIdMsg* other);

  // implements Message ----------------------------------------------

  LandmarkIdMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LandmarkIdMsg& from);
  void MergeFrom(const LandmarkIdMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ReferenceFrameIdMsg ref_frame_id = 1;
  inline bool has_ref_frame_id() const;
  inline void clear_ref_frame_id();
  static const int kRefFrameIdFieldNumber = 1;
  inline const ::pb::ReferenceFrameIdMsg& ref_frame_id() const;
  inline ::pb::ReferenceFrameIdMsg* mutable_ref_frame_id();
  inline ::pb::ReferenceFrameIdMsg* release_ref_frame_id();
  inline void set_allocated_ref_frame_id(::pb::ReferenceFrameIdMsg* ref_frame_id);

  // optional int32 landmark_id = 2;
  inline bool has_landmark_id() const;
  inline void clear_landmark_id();
  static const int kLandmarkIdFieldNumber = 2;
  inline ::google::protobuf::int32 landmark_id() const;
  inline void set_landmark_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.LandmarkIdMsg)
 private:
  inline void set_has_ref_frame_id();
  inline void clear_has_ref_frame_id();
  inline void set_has_landmark_id();
  inline void clear_has_landmark_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::ReferenceFrameIdMsg* ref_frame_id_;
  ::google::protobuf::int32 landmark_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static LandmarkIdMsg* default_instance_;
};
// -------------------------------------------------------------------

class MeasurementIdMsg : public ::google::protobuf::Message {
 public:
  MeasurementIdMsg();
  virtual ~MeasurementIdMsg();

  MeasurementIdMsg(const MeasurementIdMsg& from);

  inline MeasurementIdMsg& operator=(const MeasurementIdMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MeasurementIdMsg& default_instance();

  void Swap(MeasurementIdMsg* other);

  // implements Message ----------------------------------------------

  MeasurementIdMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MeasurementIdMsg& from);
  void MergeFrom(const MeasurementIdMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ReferenceFrameIdMsg ref_frame_id = 1;
  inline bool has_ref_frame_id() const;
  inline void clear_ref_frame_id();
  static const int kRefFrameIdFieldNumber = 1;
  inline const ::pb::ReferenceFrameIdMsg& ref_frame_id() const;
  inline ::pb::ReferenceFrameIdMsg* mutable_ref_frame_id();
  inline ::pb::ReferenceFrameIdMsg* release_ref_frame_id();
  inline void set_allocated_ref_frame_id(::pb::ReferenceFrameIdMsg* ref_frame_id);

  // optional int32 measurement_id = 2;
  inline bool has_measurement_id() const;
  inline void clear_measurement_id();
  static const int kMeasurementIdFieldNumber = 2;
  inline ::google::protobuf::int32 measurement_id() const;
  inline void set_measurement_id(::google::protobuf::int32 value);

  // optional .pb.LandmarkIdMsg landmark_id = 3;
  inline bool has_landmark_id() const;
  inline void clear_landmark_id();
  static const int kLandmarkIdFieldNumber = 3;
  inline const ::pb::LandmarkIdMsg& landmark_id() const;
  inline ::pb::LandmarkIdMsg* mutable_landmark_id();
  inline ::pb::LandmarkIdMsg* release_landmark_id();
  inline void set_allocated_landmark_id(::pb::LandmarkIdMsg* landmark_id);

  // @@protoc_insertion_point(class_scope:pb.MeasurementIdMsg)
 private:
  inline void set_has_ref_frame_id();
  inline void clear_has_ref_frame_id();
  inline void set_has_measurement_id();
  inline void clear_has_measurement_id();
  inline void set_has_landmark_id();
  inline void clear_has_landmark_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::ReferenceFrameIdMsg* ref_frame_id_;
  ::pb::LandmarkIdMsg* landmark_id_;
  ::google::protobuf::int32 measurement_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static MeasurementIdMsg* default_instance_;
};
// -------------------------------------------------------------------

class PixelMsg : public ::google::protobuf::Message {
 public:
  PixelMsg();
  virtual ~PixelMsg();

  PixelMsg(const PixelMsg& from);

  inline PixelMsg& operator=(const PixelMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PixelMsg& default_instance();

  void Swap(PixelMsg* other);

  // implements Message ----------------------------------------------

  PixelMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PixelMsg& from);
  void MergeFrom(const PixelMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double u = 1;
  inline bool has_u() const;
  inline void clear_u();
  static const int kUFieldNumber = 1;
  inline double u() const;
  inline void set_u(double value);

  // optional double v = 2;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 2;
  inline double v() const;
  inline void set_v(double value);

  // @@protoc_insertion_point(class_scope:pb.PixelMsg)
 private:
  inline void set_has_u();
  inline void clear_has_u();
  inline void set_has_v();
  inline void clear_has_v();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double u_;
  double v_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static PixelMsg* default_instance_;
};
// -------------------------------------------------------------------

class PatchHomographyMsg : public ::google::protobuf::Message {
 public:
  PatchHomographyMsg();
  virtual ~PatchHomographyMsg();

  PatchHomographyMsg(const PatchHomographyMsg& from);

  inline PatchHomographyMsg& operator=(const PatchHomographyMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PatchHomographyMsg& default_instance();

  void Swap(PatchHomographyMsg* other);

  // implements Message ----------------------------------------------

  PatchHomographyMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PatchHomographyMsg& from);
  void MergeFrom(const PatchHomographyMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);

  // optional double scale = 2;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 2;
  inline double scale() const;
  inline void set_scale(double value);

  // optional .pb.DoubleMatrixMsg h = 3;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 3;
  inline const ::pb::DoubleMatrixMsg& h() const;
  inline ::pb::DoubleMatrixMsg* mutable_h();
  inline ::pb::DoubleMatrixMsg* release_h();
  inline void set_allocated_h(::pb::DoubleMatrixMsg* h);

  // @@protoc_insertion_point(class_scope:pb.PatchHomographyMsg)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_h();
  inline void clear_has_h();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double scale_;
  ::pb::DoubleMatrixMsg* h_;
  ::google::protobuf::int32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static PatchHomographyMsg* default_instance_;
};
// -------------------------------------------------------------------

class MeasurementMsg : public ::google::protobuf::Message {
 public:
  MeasurementMsg();
  virtual ~MeasurementMsg();

  MeasurementMsg(const MeasurementMsg& from);

  inline MeasurementMsg& operator=(const MeasurementMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MeasurementMsg& default_instance();

  void Swap(MeasurementMsg* other);

  // implements Message ----------------------------------------------

  MeasurementMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MeasurementMsg& from);
  void MergeFrom(const MeasurementMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.MeasurementIdMsg id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pb::MeasurementIdMsg& id() const;
  inline ::pb::MeasurementIdMsg* mutable_id();
  inline ::pb::MeasurementIdMsg* release_id();
  inline void set_allocated_id(::pb::MeasurementIdMsg* id);

  // optional .pb.PixelMsg pixel = 2;
  inline bool has_pixel() const;
  inline void clear_pixel();
  static const int kPixelFieldNumber = 2;
  inline const ::pb::PixelMsg& pixel() const;
  inline ::pb::PixelMsg* mutable_pixel();
  inline ::pb::PixelMsg* release_pixel();
  inline void set_allocated_pixel(::pb::PixelMsg* pixel);

  // optional uint32 match_flag = 3;
  inline bool has_match_flag() const;
  inline void clear_match_flag();
  static const int kMatchFlagFieldNumber = 3;
  inline ::google::protobuf::uint32 match_flag() const;
  inline void set_match_flag(::google::protobuf::uint32 value);

  // optional double matching_error = 4;
  inline bool has_matching_error() const;
  inline void clear_matching_error();
  static const int kMatchingErrorFieldNumber = 4;
  inline double matching_error() const;
  inline void set_matching_error(double value);

  // optional double reprojection_error = 5;
  inline bool has_reprojection_error() const;
  inline void clear_reprojection_error();
  static const int kReprojectionErrorFieldNumber = 5;
  inline double reprojection_error() const;
  inline void set_reprojection_error(double value);

  // optional float scale = 6;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 6;
  inline float scale() const;
  inline void set_scale(float value);

  // optional float orientation = 7;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 7;
  inline float orientation() const;
  inline void set_orientation(float value);

  // optional .pb.PatchHomographyMsg patch_homography = 8;
  inline bool has_patch_homography() const;
  inline void clear_patch_homography();
  static const int kPatchHomographyFieldNumber = 8;
  inline const ::pb::PatchHomographyMsg& patch_homography() const;
  inline ::pb::PatchHomographyMsg* mutable_patch_homography();
  inline ::pb::PatchHomographyMsg* release_patch_homography();
  inline void set_allocated_patch_homography(::pb::PatchHomographyMsg* patch_homography);

  // optional .pb.DoubleMatrixMsg patch_vector = 9;
  inline bool has_patch_vector() const;
  inline void clear_patch_vector();
  static const int kPatchVectorFieldNumber = 9;
  inline const ::pb::DoubleMatrixMsg& patch_vector() const;
  inline ::pb::DoubleMatrixMsg* mutable_patch_vector();
  inline ::pb::DoubleMatrixMsg* release_patch_vector();
  inline void set_allocated_patch_vector(::pb::DoubleMatrixMsg* patch_vector);

  // @@protoc_insertion_point(class_scope:pb.MeasurementMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pixel();
  inline void clear_has_pixel();
  inline void set_has_match_flag();
  inline void clear_has_match_flag();
  inline void set_has_matching_error();
  inline void clear_has_matching_error();
  inline void set_has_reprojection_error();
  inline void clear_has_reprojection_error();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_patch_homography();
  inline void clear_has_patch_homography();
  inline void set_has_patch_vector();
  inline void clear_has_patch_vector();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::MeasurementIdMsg* id_;
  ::pb::PixelMsg* pixel_;
  double matching_error_;
  ::google::protobuf::uint32 match_flag_;
  float scale_;
  double reprojection_error_;
  ::pb::PatchHomographyMsg* patch_homography_;
  ::pb::DoubleMatrixMsg* patch_vector_;
  float orientation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static MeasurementMsg* default_instance_;
};
// -------------------------------------------------------------------

class MultiViewMeasurementMsg : public ::google::protobuf::Message {
 public:
  MultiViewMeasurementMsg();
  virtual ~MultiViewMeasurementMsg();

  MultiViewMeasurementMsg(const MultiViewMeasurementMsg& from);

  inline MultiViewMeasurementMsg& operator=(const MultiViewMeasurementMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiViewMeasurementMsg& default_instance();

  void Swap(MultiViewMeasurementMsg* other);

  // implements Message ----------------------------------------------

  MultiViewMeasurementMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultiViewMeasurementMsg& from);
  void MergeFrom(const MultiViewMeasurementMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.MeasurementMsg measurements = 1;
  inline int measurements_size() const;
  inline void clear_measurements();
  static const int kMeasurementsFieldNumber = 1;
  inline const ::pb::MeasurementMsg& measurements(int index) const;
  inline ::pb::MeasurementMsg* mutable_measurements(int index);
  inline ::pb::MeasurementMsg* add_measurements();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::MeasurementMsg >&
      measurements() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::MeasurementMsg >*
      mutable_measurements();

  // @@protoc_insertion_point(class_scope:pb.MultiViewMeasurementMsg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::MeasurementMsg > measurements_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static MultiViewMeasurementMsg* default_instance_;
};
// -------------------------------------------------------------------

class LandmarkMsg : public ::google::protobuf::Message {
 public:
  LandmarkMsg();
  virtual ~LandmarkMsg();

  LandmarkMsg(const LandmarkMsg& from);

  inline LandmarkMsg& operator=(const LandmarkMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LandmarkMsg& default_instance();

  void Swap(LandmarkMsg* other);

  // implements Message ----------------------------------------------

  LandmarkMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LandmarkMsg& from);
  void MergeFrom(const LandmarkMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.LandmarkIdMsg id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pb::LandmarkIdMsg& id() const;
  inline ::pb::LandmarkIdMsg* mutable_id();
  inline ::pb::LandmarkIdMsg* release_id();
  inline void set_allocated_id(::pb::LandmarkIdMsg* id);

  // optional uint32 base_camera = 2;
  inline bool has_base_camera() const;
  inline void clear_base_camera();
  static const int kBaseCameraFieldNumber = 2;
  inline ::google::protobuf::uint32 base_camera() const;
  inline void set_base_camera(::google::protobuf::uint32 value);

  // optional .pb.DoubleMatrixMsg patch = 3;
  inline bool has_patch() const;
  inline void clear_patch();
  static const int kPatchFieldNumber = 3;
  inline const ::pb::DoubleMatrixMsg& patch() const;
  inline ::pb::DoubleMatrixMsg* mutable_patch();
  inline ::pb::DoubleMatrixMsg* release_patch();
  inline void set_allocated_patch(::pb::DoubleMatrixMsg* patch);

  // optional bytes feature_descriptor = 4;
  inline bool has_feature_descriptor() const;
  inline void clear_feature_descriptor();
  static const int kFeatureDescriptorFieldNumber = 4;
  inline const ::std::string& feature_descriptor() const;
  inline void set_feature_descriptor(const ::std::string& value);
  inline void set_feature_descriptor(const char* value);
  inline void set_feature_descriptor(const void* value, size_t size);
  inline ::std::string* mutable_feature_descriptor();
  inline ::std::string* release_feature_descriptor();
  inline void set_allocated_feature_descriptor(::std::string* feature_descriptor);

  // repeated .pb.MeasurementIdMsg feature_track = 6;
  inline int feature_track_size() const;
  inline void clear_feature_track();
  static const int kFeatureTrackFieldNumber = 6;
  inline const ::pb::MeasurementIdMsg& feature_track(int index) const;
  inline ::pb::MeasurementIdMsg* mutable_feature_track(int index);
  inline ::pb::MeasurementIdMsg* add_feature_track();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::MeasurementIdMsg >&
      feature_track() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::MeasurementIdMsg >*
      mutable_feature_track();

  // optional string name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool active = 8;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 8;
  inline bool active() const;
  inline void set_active(bool value);

  // optional uint32 num_failed_track_attempts = 9;
  inline bool has_num_failed_track_attempts() const;
  inline void clear_num_failed_track_attempts();
  static const int kNumFailedTrackAttemptsFieldNumber = 9;
  inline ::google::protobuf::uint32 num_failed_track_attempts() const;
  inline void set_num_failed_track_attempts(::google::protobuf::uint32 value);

  // optional uint32 pyramid_level = 10;
  inline bool has_pyramid_level() const;
  inline void clear_pyramid_level();
  static const int kPyramidLevelFieldNumber = 10;
  inline ::google::protobuf::uint32 pyramid_level() const;
  inline void set_pyramid_level(::google::protobuf::uint32 value);

  // optional int32 landmark_state = 11;
  inline bool has_landmark_state() const;
  inline void clear_landmark_state();
  static const int kLandmarkStateFieldNumber = 11;
  inline ::google::protobuf::int32 landmark_state() const;
  inline void set_landmark_state(::google::protobuf::int32 value);

  // optional double extent = 12;
  inline bool has_extent() const;
  inline void clear_extent();
  static const int kExtentFieldNumber = 12;
  inline double extent() const;
  inline void set_extent(double value);

  // optional .pb.DoubleMatrixMsg orientation = 13;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 13;
  inline const ::pb::DoubleMatrixMsg& orientation() const;
  inline ::pb::DoubleMatrixMsg* mutable_orientation();
  inline ::pb::DoubleMatrixMsg* release_orientation();
  inline void set_allocated_orientation(::pb::DoubleMatrixMsg* orientation);

  // optional .pb.DoubleMatrixMsg relative_pos = 14;
  inline bool has_relative_pos() const;
  inline void clear_relative_pos();
  static const int kRelativePosFieldNumber = 14;
  inline const ::pb::DoubleMatrixMsg& relative_pos() const;
  inline ::pb::DoubleMatrixMsg* mutable_relative_pos();
  inline ::pb::DoubleMatrixMsg* release_relative_pos();
  inline void set_allocated_relative_pos(::pb::DoubleMatrixMsg* relative_pos);

  // @@protoc_insertion_point(class_scope:pb.LandmarkMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_base_camera();
  inline void clear_has_base_camera();
  inline void set_has_patch();
  inline void clear_has_patch();
  inline void set_has_feature_descriptor();
  inline void clear_has_feature_descriptor();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_num_failed_track_attempts();
  inline void clear_has_num_failed_track_attempts();
  inline void set_has_pyramid_level();
  inline void clear_has_pyramid_level();
  inline void set_has_landmark_state();
  inline void clear_has_landmark_state();
  inline void set_has_extent();
  inline void clear_has_extent();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_relative_pos();
  inline void clear_has_relative_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::LandmarkIdMsg* id_;
  ::pb::DoubleMatrixMsg* patch_;
  ::std::string* feature_descriptor_;
  ::google::protobuf::uint32 base_camera_;
  bool active_;
  ::google::protobuf::RepeatedPtrField< ::pb::MeasurementIdMsg > feature_track_;
  ::std::string* name_;
  ::google::protobuf::uint32 num_failed_track_attempts_;
  ::google::protobuf::uint32 pyramid_level_;
  double extent_;
  ::pb::DoubleMatrixMsg* orientation_;
  ::pb::DoubleMatrixMsg* relative_pos_;
  ::google::protobuf::int32 landmark_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static LandmarkMsg* default_instance_;
};
// -------------------------------------------------------------------

class TransformEdgeMsg : public ::google::protobuf::Message {
 public:
  TransformEdgeMsg();
  virtual ~TransformEdgeMsg();

  TransformEdgeMsg(const TransformEdgeMsg& from);

  inline TransformEdgeMsg& operator=(const TransformEdgeMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransformEdgeMsg& default_instance();

  void Swap(TransformEdgeMsg* other);

  // implements Message ----------------------------------------------

  TransformEdgeMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransformEdgeMsg& from);
  void MergeFrom(const TransformEdgeMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.TransformEdgeIdMsg id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pb::TransformEdgeIdMsg& id() const;
  inline ::pb::TransformEdgeIdMsg* mutable_id();
  inline ::pb::TransformEdgeIdMsg* release_id();
  inline void set_allocated_id(::pb::TransformEdgeIdMsg* id);

  // optional double last_modified_time = 2;
  inline bool has_last_modified_time() const;
  inline void clear_last_modified_time();
  static const int kLastModifiedTimeFieldNumber = 2;
  inline double last_modified_time() const;
  inline void set_last_modified_time(double value);

  // optional .pb.DoubleMatrixMsg transform = 4;
  inline bool has_transform() const;
  inline void clear_transform();
  static const int kTransformFieldNumber = 4;
  inline const ::pb::DoubleMatrixMsg& transform() const;
  inline ::pb::DoubleMatrixMsg* mutable_transform();
  inline ::pb::DoubleMatrixMsg* release_transform();
  inline void set_allocated_transform(::pb::DoubleMatrixMsg* transform);

  // optional .pb.DoubleMatrixMsg g = 5;
  inline bool has_g() const;
  inline void clear_g();
  static const int kGFieldNumber = 5;
  inline const ::pb::DoubleMatrixMsg& g() const;
  inline ::pb::DoubleMatrixMsg* mutable_g();
  inline ::pb::DoubleMatrixMsg* release_g();
  inline void set_allocated_g(::pb::DoubleMatrixMsg* g);

  // optional bool is_broken = 6;
  inline bool has_is_broken() const;
  inline void clear_is_broken();
  static const int kIsBrokenFieldNumber = 6;
  inline bool is_broken() const;
  inline void set_is_broken(bool value);

  // optional bool is_loop_closure = 7;
  inline bool has_is_loop_closure() const;
  inline void clear_is_loop_closure();
  static const int kIsLoopClosureFieldNumber = 7;
  inline bool is_loop_closure() const;
  inline void set_is_loop_closure(bool value);

  // @@protoc_insertion_point(class_scope:pb.TransformEdgeMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_last_modified_time();
  inline void clear_has_last_modified_time();
  inline void set_has_transform();
  inline void clear_has_transform();
  inline void set_has_g();
  inline void clear_has_g();
  inline void set_has_is_broken();
  inline void clear_has_is_broken();
  inline void set_has_is_loop_closure();
  inline void clear_has_is_loop_closure();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::TransformEdgeIdMsg* id_;
  double last_modified_time_;
  ::pb::DoubleMatrixMsg* transform_;
  ::pb::DoubleMatrixMsg* g_;
  bool is_broken_;
  bool is_loop_closure_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static TransformEdgeMsg* default_instance_;
};
// -------------------------------------------------------------------

class ReferenceFrameMsg : public ::google::protobuf::Message {
 public:
  ReferenceFrameMsg();
  virtual ~ReferenceFrameMsg();

  ReferenceFrameMsg(const ReferenceFrameMsg& from);

  inline ReferenceFrameMsg& operator=(const ReferenceFrameMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceFrameMsg& default_instance();

  void Swap(ReferenceFrameMsg* other);

  // implements Message ----------------------------------------------

  ReferenceFrameMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReferenceFrameMsg& from);
  void MergeFrom(const ReferenceFrameMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ReferenceFrameIdMsg id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::pb::ReferenceFrameIdMsg& id() const;
  inline ::pb::ReferenceFrameIdMsg* mutable_id();
  inline ::pb::ReferenceFrameIdMsg* release_id();
  inline void set_allocated_id(::pb::ReferenceFrameIdMsg* id);

  // optional .pb.TransformEdgeIdMsg parent_edge_id = 2;
  inline bool has_parent_edge_id() const;
  inline void clear_parent_edge_id();
  static const int kParentEdgeIdFieldNumber = 2;
  inline const ::pb::TransformEdgeIdMsg& parent_edge_id() const;
  inline ::pb::TransformEdgeIdMsg* mutable_parent_edge_id();
  inline ::pb::TransformEdgeIdMsg* release_parent_edge_id();
  inline void set_allocated_parent_edge_id(::pb::TransformEdgeIdMsg* parent_edge_id);

  // repeated .pb.TransformEdgeIdMsg neighbor_edge_ids = 3;
  inline int neighbor_edge_ids_size() const;
  inline void clear_neighbor_edge_ids();
  static const int kNeighborEdgeIdsFieldNumber = 3;
  inline const ::pb::TransformEdgeIdMsg& neighbor_edge_ids(int index) const;
  inline ::pb::TransformEdgeIdMsg* mutable_neighbor_edge_ids(int index);
  inline ::pb::TransformEdgeIdMsg* add_neighbor_edge_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TransformEdgeIdMsg >&
      neighbor_edge_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TransformEdgeIdMsg >*
      mutable_neighbor_edge_ids();

  // optional double sensor_time = 4;
  inline bool has_sensor_time() const;
  inline void clear_sensor_time();
  static const int kSensorTimeFieldNumber = 4;
  inline double sensor_time() const;
  inline void set_sensor_time(double value);

  // optional bool is_isolated = 5;
  inline bool has_is_isolated() const;
  inline void clear_is_isolated();
  static const int kIsIsolatedFieldNumber = 5;
  inline bool is_isolated() const;
  inline void set_is_isolated(bool value);

  // repeated .pb.LandmarkMsg landmarks = 6;
  inline int landmarks_size() const;
  inline void clear_landmarks();
  static const int kLandmarksFieldNumber = 6;
  inline const ::pb::LandmarkMsg& landmarks(int index) const;
  inline ::pb::LandmarkMsg* mutable_landmarks(int index);
  inline ::pb::LandmarkMsg* add_landmarks();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::LandmarkMsg >&
      landmarks() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::LandmarkMsg >*
      mutable_landmarks();

  // repeated .pb.MultiViewMeasurementMsg measurements = 7;
  inline int measurements_size() const;
  inline void clear_measurements();
  static const int kMeasurementsFieldNumber = 7;
  inline const ::pb::MultiViewMeasurementMsg& measurements(int index) const;
  inline ::pb::MultiViewMeasurementMsg* mutable_measurements(int index);
  inline ::pb::MultiViewMeasurementMsg* add_measurements();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::MultiViewMeasurementMsg >&
      measurements() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::MultiViewMeasurementMsg >*
      mutable_measurements();

  // optional .pb.DoubleMatrixMsg velocity = 8;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 8;
  inline const ::pb::DoubleMatrixMsg& velocity() const;
  inline ::pb::DoubleMatrixMsg* mutable_velocity();
  inline ::pb::DoubleMatrixMsg* release_velocity();
  inline void set_allocated_velocity(::pb::DoubleMatrixMsg* velocity);

  // optional double last_modified_time = 9;
  inline bool has_last_modified_time() const;
  inline void clear_last_modified_time();
  static const int kLastModifiedTimeFieldNumber = 9;
  inline double last_modified_time() const;
  inline void set_last_modified_time(double value);

  // repeated .pb.FrameObjectMsg objects = 10;
  inline int objects_size() const;
  inline void clear_objects();
  static const int kObjectsFieldNumber = 10;
  inline const ::pb::FrameObjectMsg& objects(int index) const;
  inline ::pb::FrameObjectMsg* mutable_objects(int index);
  inline ::pb::FrameObjectMsg* add_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::FrameObjectMsg >&
      objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::FrameObjectMsg >*
      mutable_objects();

  // optional .pb.DoubleMatrixMsg gravity = 11;
  inline bool has_gravity() const;
  inline void clear_gravity();
  static const int kGravityFieldNumber = 11;
  inline const ::pb::DoubleMatrixMsg& gravity() const;
  inline ::pb::DoubleMatrixMsg* mutable_gravity();
  inline ::pb::DoubleMatrixMsg* release_gravity();
  inline void set_allocated_gravity(::pb::DoubleMatrixMsg* gravity);

  // optional .pb.DoubleMatrixMsg biases = 12;
  inline bool has_biases() const;
  inline void clear_biases();
  static const int kBiasesFieldNumber = 12;
  inline const ::pb::DoubleMatrixMsg& biases() const;
  inline ::pb::DoubleMatrixMsg* mutable_biases();
  inline ::pb::DoubleMatrixMsg* release_biases();
  inline void set_allocated_biases(::pb::DoubleMatrixMsg* biases);

  // @@protoc_insertion_point(class_scope:pb.ReferenceFrameMsg)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_parent_edge_id();
  inline void clear_has_parent_edge_id();
  inline void set_has_sensor_time();
  inline void clear_has_sensor_time();
  inline void set_has_is_isolated();
  inline void clear_has_is_isolated();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_last_modified_time();
  inline void clear_has_last_modified_time();
  inline void set_has_gravity();
  inline void clear_has_gravity();
  inline void set_has_biases();
  inline void clear_has_biases();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::ReferenceFrameIdMsg* id_;
  ::pb::TransformEdgeIdMsg* parent_edge_id_;
  ::google::protobuf::RepeatedPtrField< ::pb::TransformEdgeIdMsg > neighbor_edge_ids_;
  double sensor_time_;
  ::google::protobuf::RepeatedPtrField< ::pb::LandmarkMsg > landmarks_;
  ::google::protobuf::RepeatedPtrField< ::pb::MultiViewMeasurementMsg > measurements_;
  ::pb::DoubleMatrixMsg* velocity_;
  double last_modified_time_;
  ::google::protobuf::RepeatedPtrField< ::pb::FrameObjectMsg > objects_;
  ::pb::DoubleMatrixMsg* gravity_;
  ::pb::DoubleMatrixMsg* biases_;
  bool is_isolated_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static ReferenceFrameMsg* default_instance_;
};
// -------------------------------------------------------------------

class CameraRigMsg : public ::google::protobuf::Message {
 public:
  CameraRigMsg();
  virtual ~CameraRigMsg();

  CameraRigMsg(const CameraRigMsg& from);

  inline CameraRigMsg& operator=(const CameraRigMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraRigMsg& default_instance();

  void Swap(CameraRigMsg* other);

  // implements Message ----------------------------------------------

  CameraRigMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraRigMsg& from);
  void MergeFrom(const CameraRigMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.CameraModelMsg cameras = 1;
  inline int cameras_size() const;
  inline void clear_cameras();
  static const int kCamerasFieldNumber = 1;
  inline const ::pb::CameraModelMsg& cameras(int index) const;
  inline ::pb::CameraModelMsg* mutable_cameras(int index);
  inline ::pb::CameraModelMsg* add_cameras();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::CameraModelMsg >&
      cameras() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::CameraModelMsg >*
      mutable_cameras();

  // @@protoc_insertion_point(class_scope:pb.CameraRigMsg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::CameraModelMsg > cameras_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static CameraRigMsg* default_instance_;
};
// -------------------------------------------------------------------

class SlamMapMsg : public ::google::protobuf::Message {
 public:
  SlamMapMsg();
  virtual ~SlamMapMsg();

  SlamMapMsg(const SlamMapMsg& from);

  inline SlamMapMsg& operator=(const SlamMapMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlamMapMsg& default_instance();

  void Swap(SlamMapMsg* other);

  // implements Message ----------------------------------------------

  SlamMapMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SlamMapMsg& from);
  void MergeFrom(const SlamMapMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.SessionIdMsg session_ids = 1;
  inline int session_ids_size() const;
  inline void clear_session_ids();
  static const int kSessionIdsFieldNumber = 1;
  inline const ::pb::SessionIdMsg& session_ids(int index) const;
  inline ::pb::SessionIdMsg* mutable_session_ids(int index);
  inline ::pb::SessionIdMsg* add_session_ids();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::SessionIdMsg >&
      session_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::SessionIdMsg >*
      mutable_session_ids();

  // repeated .pb.CameraRigMsg rigs = 2;
  inline int rigs_size() const;
  inline void clear_rigs();
  static const int kRigsFieldNumber = 2;
  inline const ::pb::CameraRigMsg& rigs(int index) const;
  inline ::pb::CameraRigMsg* mutable_rigs(int index);
  inline ::pb::CameraRigMsg* add_rigs();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::CameraRigMsg >&
      rigs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::CameraRigMsg >*
      mutable_rigs();

  // repeated .pb.ReferenceFrameMsg nodes = 3;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 3;
  inline const ::pb::ReferenceFrameMsg& nodes(int index) const;
  inline ::pb::ReferenceFrameMsg* mutable_nodes(int index);
  inline ::pb::ReferenceFrameMsg* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::ReferenceFrameMsg >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::ReferenceFrameMsg >*
      mutable_nodes();

  // repeated .pb.TransformEdgeMsg edges = 4;
  inline int edges_size() const;
  inline void clear_edges();
  static const int kEdgesFieldNumber = 4;
  inline const ::pb::TransformEdgeMsg& edges(int index) const;
  inline ::pb::TransformEdgeMsg* mutable_edges(int index);
  inline ::pb::TransformEdgeMsg* add_edges();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TransformEdgeMsg >&
      edges() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TransformEdgeMsg >*
      mutable_edges();

  // @@protoc_insertion_point(class_scope:pb.SlamMapMsg)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::SessionIdMsg > session_ids_;
  ::google::protobuf::RepeatedPtrField< ::pb::CameraRigMsg > rigs_;
  ::google::protobuf::RepeatedPtrField< ::pb::ReferenceFrameMsg > nodes_;
  ::google::protobuf::RepeatedPtrField< ::pb::TransformEdgeMsg > edges_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_rslam_2eproto();
  friend void protobuf_AssignDesc_rslam_2eproto();
  friend void protobuf_ShutdownFile_rslam_2eproto();

  void InitAsDefaultInstance();
  static SlamMapMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// SessionIdMsg

// optional bytes uuid = 1;
inline bool SessionIdMsg::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionIdMsg::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionIdMsg::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionIdMsg::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& SessionIdMsg::uuid() const {
  return *uuid_;
}
inline void SessionIdMsg::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void SessionIdMsg::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void SessionIdMsg::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionIdMsg::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* SessionIdMsg::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionIdMsg::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReferenceFrameIdMsg

// optional uint32 frame_id = 1;
inline bool ReferenceFrameIdMsg::has_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferenceFrameIdMsg::set_has_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferenceFrameIdMsg::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferenceFrameIdMsg::clear_frame_id() {
  frame_id_ = 0u;
  clear_has_frame_id();
}
inline ::google::protobuf::uint32 ReferenceFrameIdMsg::frame_id() const {
  return frame_id_;
}
inline void ReferenceFrameIdMsg::set_frame_id(::google::protobuf::uint32 value) {
  set_has_frame_id();
  frame_id_ = value;
}

// optional .pb.SessionIdMsg session_id = 2;
inline bool ReferenceFrameIdMsg::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReferenceFrameIdMsg::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReferenceFrameIdMsg::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReferenceFrameIdMsg::clear_session_id() {
  if (session_id_ != NULL) session_id_->::pb::SessionIdMsg::Clear();
  clear_has_session_id();
}
inline const ::pb::SessionIdMsg& ReferenceFrameIdMsg::session_id() const {
  return session_id_ != NULL ? *session_id_ : *default_instance_->session_id_;
}
inline ::pb::SessionIdMsg* ReferenceFrameIdMsg::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == NULL) session_id_ = new ::pb::SessionIdMsg;
  return session_id_;
}
inline ::pb::SessionIdMsg* ReferenceFrameIdMsg::release_session_id() {
  clear_has_session_id();
  ::pb::SessionIdMsg* temp = session_id_;
  session_id_ = NULL;
  return temp;
}
inline void ReferenceFrameIdMsg::set_allocated_session_id(::pb::SessionIdMsg* session_id) {
  delete session_id_;
  session_id_ = session_id;
  if (session_id) {
    set_has_session_id();
  } else {
    clear_has_session_id();
  }
}

// -------------------------------------------------------------------

// TransformEdgeIdMsg

// optional int32 edge_id = 1;
inline bool TransformEdgeIdMsg::has_edge_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransformEdgeIdMsg::set_has_edge_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransformEdgeIdMsg::clear_has_edge_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransformEdgeIdMsg::clear_edge_id() {
  edge_id_ = 0;
  clear_has_edge_id();
}
inline ::google::protobuf::int32 TransformEdgeIdMsg::edge_id() const {
  return edge_id_;
}
inline void TransformEdgeIdMsg::set_edge_id(::google::protobuf::int32 value) {
  set_has_edge_id();
  edge_id_ = value;
}

// optional .pb.SessionIdMsg session_id = 2;
inline bool TransformEdgeIdMsg::has_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransformEdgeIdMsg::set_has_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransformEdgeIdMsg::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransformEdgeIdMsg::clear_session_id() {
  if (session_id_ != NULL) session_id_->::pb::SessionIdMsg::Clear();
  clear_has_session_id();
}
inline const ::pb::SessionIdMsg& TransformEdgeIdMsg::session_id() const {
  return session_id_ != NULL ? *session_id_ : *default_instance_->session_id_;
}
inline ::pb::SessionIdMsg* TransformEdgeIdMsg::mutable_session_id() {
  set_has_session_id();
  if (session_id_ == NULL) session_id_ = new ::pb::SessionIdMsg;
  return session_id_;
}
inline ::pb::SessionIdMsg* TransformEdgeIdMsg::release_session_id() {
  clear_has_session_id();
  ::pb::SessionIdMsg* temp = session_id_;
  session_id_ = NULL;
  return temp;
}
inline void TransformEdgeIdMsg::set_allocated_session_id(::pb::SessionIdMsg* session_id) {
  delete session_id_;
  session_id_ = session_id;
  if (session_id) {
    set_has_session_id();
  } else {
    clear_has_session_id();
  }
}

// optional .pb.ReferenceFrameIdMsg start = 3;
inline bool TransformEdgeIdMsg::has_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransformEdgeIdMsg::set_has_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransformEdgeIdMsg::clear_has_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransformEdgeIdMsg::clear_start() {
  if (start_ != NULL) start_->::pb::ReferenceFrameIdMsg::Clear();
  clear_has_start();
}
inline const ::pb::ReferenceFrameIdMsg& TransformEdgeIdMsg::start() const {
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::pb::ReferenceFrameIdMsg* TransformEdgeIdMsg::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::pb::ReferenceFrameIdMsg;
  return start_;
}
inline ::pb::ReferenceFrameIdMsg* TransformEdgeIdMsg::release_start() {
  clear_has_start();
  ::pb::ReferenceFrameIdMsg* temp = start_;
  start_ = NULL;
  return temp;
}
inline void TransformEdgeIdMsg::set_allocated_start(::pb::ReferenceFrameIdMsg* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
}

// optional .pb.ReferenceFrameIdMsg end = 4;
inline bool TransformEdgeIdMsg::has_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransformEdgeIdMsg::set_has_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransformEdgeIdMsg::clear_has_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransformEdgeIdMsg::clear_end() {
  if (end_ != NULL) end_->::pb::ReferenceFrameIdMsg::Clear();
  clear_has_end();
}
inline const ::pb::ReferenceFrameIdMsg& TransformEdgeIdMsg::end() const {
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::pb::ReferenceFrameIdMsg* TransformEdgeIdMsg::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::pb::ReferenceFrameIdMsg;
  return end_;
}
inline ::pb::ReferenceFrameIdMsg* TransformEdgeIdMsg::release_end() {
  clear_has_end();
  ::pb::ReferenceFrameIdMsg* temp = end_;
  end_ = NULL;
  return temp;
}
inline void TransformEdgeIdMsg::set_allocated_end(::pb::ReferenceFrameIdMsg* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
}

// -------------------------------------------------------------------

// LandmarkIdMsg

// optional .pb.ReferenceFrameIdMsg ref_frame_id = 1;
inline bool LandmarkIdMsg::has_ref_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LandmarkIdMsg::set_has_ref_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LandmarkIdMsg::clear_has_ref_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LandmarkIdMsg::clear_ref_frame_id() {
  if (ref_frame_id_ != NULL) ref_frame_id_->::pb::ReferenceFrameIdMsg::Clear();
  clear_has_ref_frame_id();
}
inline const ::pb::ReferenceFrameIdMsg& LandmarkIdMsg::ref_frame_id() const {
  return ref_frame_id_ != NULL ? *ref_frame_id_ : *default_instance_->ref_frame_id_;
}
inline ::pb::ReferenceFrameIdMsg* LandmarkIdMsg::mutable_ref_frame_id() {
  set_has_ref_frame_id();
  if (ref_frame_id_ == NULL) ref_frame_id_ = new ::pb::ReferenceFrameIdMsg;
  return ref_frame_id_;
}
inline ::pb::ReferenceFrameIdMsg* LandmarkIdMsg::release_ref_frame_id() {
  clear_has_ref_frame_id();
  ::pb::ReferenceFrameIdMsg* temp = ref_frame_id_;
  ref_frame_id_ = NULL;
  return temp;
}
inline void LandmarkIdMsg::set_allocated_ref_frame_id(::pb::ReferenceFrameIdMsg* ref_frame_id) {
  delete ref_frame_id_;
  ref_frame_id_ = ref_frame_id;
  if (ref_frame_id) {
    set_has_ref_frame_id();
  } else {
    clear_has_ref_frame_id();
  }
}

// optional int32 landmark_id = 2;
inline bool LandmarkIdMsg::has_landmark_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LandmarkIdMsg::set_has_landmark_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LandmarkIdMsg::clear_has_landmark_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LandmarkIdMsg::clear_landmark_id() {
  landmark_id_ = 0;
  clear_has_landmark_id();
}
inline ::google::protobuf::int32 LandmarkIdMsg::landmark_id() const {
  return landmark_id_;
}
inline void LandmarkIdMsg::set_landmark_id(::google::protobuf::int32 value) {
  set_has_landmark_id();
  landmark_id_ = value;
}

// -------------------------------------------------------------------

// MeasurementIdMsg

// optional .pb.ReferenceFrameIdMsg ref_frame_id = 1;
inline bool MeasurementIdMsg::has_ref_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeasurementIdMsg::set_has_ref_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeasurementIdMsg::clear_has_ref_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeasurementIdMsg::clear_ref_frame_id() {
  if (ref_frame_id_ != NULL) ref_frame_id_->::pb::ReferenceFrameIdMsg::Clear();
  clear_has_ref_frame_id();
}
inline const ::pb::ReferenceFrameIdMsg& MeasurementIdMsg::ref_frame_id() const {
  return ref_frame_id_ != NULL ? *ref_frame_id_ : *default_instance_->ref_frame_id_;
}
inline ::pb::ReferenceFrameIdMsg* MeasurementIdMsg::mutable_ref_frame_id() {
  set_has_ref_frame_id();
  if (ref_frame_id_ == NULL) ref_frame_id_ = new ::pb::ReferenceFrameIdMsg;
  return ref_frame_id_;
}
inline ::pb::ReferenceFrameIdMsg* MeasurementIdMsg::release_ref_frame_id() {
  clear_has_ref_frame_id();
  ::pb::ReferenceFrameIdMsg* temp = ref_frame_id_;
  ref_frame_id_ = NULL;
  return temp;
}
inline void MeasurementIdMsg::set_allocated_ref_frame_id(::pb::ReferenceFrameIdMsg* ref_frame_id) {
  delete ref_frame_id_;
  ref_frame_id_ = ref_frame_id;
  if (ref_frame_id) {
    set_has_ref_frame_id();
  } else {
    clear_has_ref_frame_id();
  }
}

// optional int32 measurement_id = 2;
inline bool MeasurementIdMsg::has_measurement_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MeasurementIdMsg::set_has_measurement_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MeasurementIdMsg::clear_has_measurement_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MeasurementIdMsg::clear_measurement_id() {
  measurement_id_ = 0;
  clear_has_measurement_id();
}
inline ::google::protobuf::int32 MeasurementIdMsg::measurement_id() const {
  return measurement_id_;
}
inline void MeasurementIdMsg::set_measurement_id(::google::protobuf::int32 value) {
  set_has_measurement_id();
  measurement_id_ = value;
}

// optional .pb.LandmarkIdMsg landmark_id = 3;
inline bool MeasurementIdMsg::has_landmark_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MeasurementIdMsg::set_has_landmark_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MeasurementIdMsg::clear_has_landmark_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MeasurementIdMsg::clear_landmark_id() {
  if (landmark_id_ != NULL) landmark_id_->::pb::LandmarkIdMsg::Clear();
  clear_has_landmark_id();
}
inline const ::pb::LandmarkIdMsg& MeasurementIdMsg::landmark_id() const {
  return landmark_id_ != NULL ? *landmark_id_ : *default_instance_->landmark_id_;
}
inline ::pb::LandmarkIdMsg* MeasurementIdMsg::mutable_landmark_id() {
  set_has_landmark_id();
  if (landmark_id_ == NULL) landmark_id_ = new ::pb::LandmarkIdMsg;
  return landmark_id_;
}
inline ::pb::LandmarkIdMsg* MeasurementIdMsg::release_landmark_id() {
  clear_has_landmark_id();
  ::pb::LandmarkIdMsg* temp = landmark_id_;
  landmark_id_ = NULL;
  return temp;
}
inline void MeasurementIdMsg::set_allocated_landmark_id(::pb::LandmarkIdMsg* landmark_id) {
  delete landmark_id_;
  landmark_id_ = landmark_id;
  if (landmark_id) {
    set_has_landmark_id();
  } else {
    clear_has_landmark_id();
  }
}

// -------------------------------------------------------------------

// PixelMsg

// optional double u = 1;
inline bool PixelMsg::has_u() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PixelMsg::set_has_u() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PixelMsg::clear_has_u() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PixelMsg::clear_u() {
  u_ = 0;
  clear_has_u();
}
inline double PixelMsg::u() const {
  return u_;
}
inline void PixelMsg::set_u(double value) {
  set_has_u();
  u_ = value;
}

// optional double v = 2;
inline bool PixelMsg::has_v() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PixelMsg::set_has_v() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PixelMsg::clear_has_v() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PixelMsg::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline double PixelMsg::v() const {
  return v_;
}
inline void PixelMsg::set_v(double value) {
  set_has_v();
  v_ = value;
}

// -------------------------------------------------------------------

// PatchHomographyMsg

// optional int32 state = 1;
inline bool PatchHomographyMsg::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PatchHomographyMsg::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PatchHomographyMsg::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PatchHomographyMsg::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 PatchHomographyMsg::state() const {
  return state_;
}
inline void PatchHomographyMsg::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// optional double scale = 2;
inline bool PatchHomographyMsg::has_scale() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PatchHomographyMsg::set_has_scale() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PatchHomographyMsg::clear_has_scale() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PatchHomographyMsg::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline double PatchHomographyMsg::scale() const {
  return scale_;
}
inline void PatchHomographyMsg::set_scale(double value) {
  set_has_scale();
  scale_ = value;
}

// optional .pb.DoubleMatrixMsg h = 3;
inline bool PatchHomographyMsg::has_h() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PatchHomographyMsg::set_has_h() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PatchHomographyMsg::clear_has_h() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PatchHomographyMsg::clear_h() {
  if (h_ != NULL) h_->::pb::DoubleMatrixMsg::Clear();
  clear_has_h();
}
inline const ::pb::DoubleMatrixMsg& PatchHomographyMsg::h() const {
  return h_ != NULL ? *h_ : *default_instance_->h_;
}
inline ::pb::DoubleMatrixMsg* PatchHomographyMsg::mutable_h() {
  set_has_h();
  if (h_ == NULL) h_ = new ::pb::DoubleMatrixMsg;
  return h_;
}
inline ::pb::DoubleMatrixMsg* PatchHomographyMsg::release_h() {
  clear_has_h();
  ::pb::DoubleMatrixMsg* temp = h_;
  h_ = NULL;
  return temp;
}
inline void PatchHomographyMsg::set_allocated_h(::pb::DoubleMatrixMsg* h) {
  delete h_;
  h_ = h;
  if (h) {
    set_has_h();
  } else {
    clear_has_h();
  }
}

// -------------------------------------------------------------------

// MeasurementMsg

// optional .pb.MeasurementIdMsg id = 1;
inline bool MeasurementMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeasurementMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeasurementMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeasurementMsg::clear_id() {
  if (id_ != NULL) id_->::pb::MeasurementIdMsg::Clear();
  clear_has_id();
}
inline const ::pb::MeasurementIdMsg& MeasurementMsg::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pb::MeasurementIdMsg* MeasurementMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pb::MeasurementIdMsg;
  return id_;
}
inline ::pb::MeasurementIdMsg* MeasurementMsg::release_id() {
  clear_has_id();
  ::pb::MeasurementIdMsg* temp = id_;
  id_ = NULL;
  return temp;
}
inline void MeasurementMsg::set_allocated_id(::pb::MeasurementIdMsg* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional .pb.PixelMsg pixel = 2;
inline bool MeasurementMsg::has_pixel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MeasurementMsg::set_has_pixel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MeasurementMsg::clear_has_pixel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MeasurementMsg::clear_pixel() {
  if (pixel_ != NULL) pixel_->::pb::PixelMsg::Clear();
  clear_has_pixel();
}
inline const ::pb::PixelMsg& MeasurementMsg::pixel() const {
  return pixel_ != NULL ? *pixel_ : *default_instance_->pixel_;
}
inline ::pb::PixelMsg* MeasurementMsg::mutable_pixel() {
  set_has_pixel();
  if (pixel_ == NULL) pixel_ = new ::pb::PixelMsg;
  return pixel_;
}
inline ::pb::PixelMsg* MeasurementMsg::release_pixel() {
  clear_has_pixel();
  ::pb::PixelMsg* temp = pixel_;
  pixel_ = NULL;
  return temp;
}
inline void MeasurementMsg::set_allocated_pixel(::pb::PixelMsg* pixel) {
  delete pixel_;
  pixel_ = pixel;
  if (pixel) {
    set_has_pixel();
  } else {
    clear_has_pixel();
  }
}

// optional uint32 match_flag = 3;
inline bool MeasurementMsg::has_match_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MeasurementMsg::set_has_match_flag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MeasurementMsg::clear_has_match_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MeasurementMsg::clear_match_flag() {
  match_flag_ = 0u;
  clear_has_match_flag();
}
inline ::google::protobuf::uint32 MeasurementMsg::match_flag() const {
  return match_flag_;
}
inline void MeasurementMsg::set_match_flag(::google::protobuf::uint32 value) {
  set_has_match_flag();
  match_flag_ = value;
}

// optional double matching_error = 4;
inline bool MeasurementMsg::has_matching_error() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MeasurementMsg::set_has_matching_error() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MeasurementMsg::clear_has_matching_error() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MeasurementMsg::clear_matching_error() {
  matching_error_ = 0;
  clear_has_matching_error();
}
inline double MeasurementMsg::matching_error() const {
  return matching_error_;
}
inline void MeasurementMsg::set_matching_error(double value) {
  set_has_matching_error();
  matching_error_ = value;
}

// optional double reprojection_error = 5;
inline bool MeasurementMsg::has_reprojection_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MeasurementMsg::set_has_reprojection_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MeasurementMsg::clear_has_reprojection_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MeasurementMsg::clear_reprojection_error() {
  reprojection_error_ = 0;
  clear_has_reprojection_error();
}
inline double MeasurementMsg::reprojection_error() const {
  return reprojection_error_;
}
inline void MeasurementMsg::set_reprojection_error(double value) {
  set_has_reprojection_error();
  reprojection_error_ = value;
}

// optional float scale = 6;
inline bool MeasurementMsg::has_scale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MeasurementMsg::set_has_scale() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MeasurementMsg::clear_has_scale() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MeasurementMsg::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float MeasurementMsg::scale() const {
  return scale_;
}
inline void MeasurementMsg::set_scale(float value) {
  set_has_scale();
  scale_ = value;
}

// optional float orientation = 7;
inline bool MeasurementMsg::has_orientation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MeasurementMsg::set_has_orientation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MeasurementMsg::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MeasurementMsg::clear_orientation() {
  orientation_ = 0;
  clear_has_orientation();
}
inline float MeasurementMsg::orientation() const {
  return orientation_;
}
inline void MeasurementMsg::set_orientation(float value) {
  set_has_orientation();
  orientation_ = value;
}

// optional .pb.PatchHomographyMsg patch_homography = 8;
inline bool MeasurementMsg::has_patch_homography() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MeasurementMsg::set_has_patch_homography() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MeasurementMsg::clear_has_patch_homography() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MeasurementMsg::clear_patch_homography() {
  if (patch_homography_ != NULL) patch_homography_->::pb::PatchHomographyMsg::Clear();
  clear_has_patch_homography();
}
inline const ::pb::PatchHomographyMsg& MeasurementMsg::patch_homography() const {
  return patch_homography_ != NULL ? *patch_homography_ : *default_instance_->patch_homography_;
}
inline ::pb::PatchHomographyMsg* MeasurementMsg::mutable_patch_homography() {
  set_has_patch_homography();
  if (patch_homography_ == NULL) patch_homography_ = new ::pb::PatchHomographyMsg;
  return patch_homography_;
}
inline ::pb::PatchHomographyMsg* MeasurementMsg::release_patch_homography() {
  clear_has_patch_homography();
  ::pb::PatchHomographyMsg* temp = patch_homography_;
  patch_homography_ = NULL;
  return temp;
}
inline void MeasurementMsg::set_allocated_patch_homography(::pb::PatchHomographyMsg* patch_homography) {
  delete patch_homography_;
  patch_homography_ = patch_homography;
  if (patch_homography) {
    set_has_patch_homography();
  } else {
    clear_has_patch_homography();
  }
}

// optional .pb.DoubleMatrixMsg patch_vector = 9;
inline bool MeasurementMsg::has_patch_vector() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MeasurementMsg::set_has_patch_vector() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MeasurementMsg::clear_has_patch_vector() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MeasurementMsg::clear_patch_vector() {
  if (patch_vector_ != NULL) patch_vector_->::pb::DoubleMatrixMsg::Clear();
  clear_has_patch_vector();
}
inline const ::pb::DoubleMatrixMsg& MeasurementMsg::patch_vector() const {
  return patch_vector_ != NULL ? *patch_vector_ : *default_instance_->patch_vector_;
}
inline ::pb::DoubleMatrixMsg* MeasurementMsg::mutable_patch_vector() {
  set_has_patch_vector();
  if (patch_vector_ == NULL) patch_vector_ = new ::pb::DoubleMatrixMsg;
  return patch_vector_;
}
inline ::pb::DoubleMatrixMsg* MeasurementMsg::release_patch_vector() {
  clear_has_patch_vector();
  ::pb::DoubleMatrixMsg* temp = patch_vector_;
  patch_vector_ = NULL;
  return temp;
}
inline void MeasurementMsg::set_allocated_patch_vector(::pb::DoubleMatrixMsg* patch_vector) {
  delete patch_vector_;
  patch_vector_ = patch_vector;
  if (patch_vector) {
    set_has_patch_vector();
  } else {
    clear_has_patch_vector();
  }
}

// -------------------------------------------------------------------

// MultiViewMeasurementMsg

// repeated .pb.MeasurementMsg measurements = 1;
inline int MultiViewMeasurementMsg::measurements_size() const {
  return measurements_.size();
}
inline void MultiViewMeasurementMsg::clear_measurements() {
  measurements_.Clear();
}
inline const ::pb::MeasurementMsg& MultiViewMeasurementMsg::measurements(int index) const {
  return measurements_.Get(index);
}
inline ::pb::MeasurementMsg* MultiViewMeasurementMsg::mutable_measurements(int index) {
  return measurements_.Mutable(index);
}
inline ::pb::MeasurementMsg* MultiViewMeasurementMsg::add_measurements() {
  return measurements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::MeasurementMsg >&
MultiViewMeasurementMsg::measurements() const {
  return measurements_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::MeasurementMsg >*
MultiViewMeasurementMsg::mutable_measurements() {
  return &measurements_;
}

// -------------------------------------------------------------------

// LandmarkMsg

// optional .pb.LandmarkIdMsg id = 1;
inline bool LandmarkMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LandmarkMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LandmarkMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LandmarkMsg::clear_id() {
  if (id_ != NULL) id_->::pb::LandmarkIdMsg::Clear();
  clear_has_id();
}
inline const ::pb::LandmarkIdMsg& LandmarkMsg::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pb::LandmarkIdMsg* LandmarkMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pb::LandmarkIdMsg;
  return id_;
}
inline ::pb::LandmarkIdMsg* LandmarkMsg::release_id() {
  clear_has_id();
  ::pb::LandmarkIdMsg* temp = id_;
  id_ = NULL;
  return temp;
}
inline void LandmarkMsg::set_allocated_id(::pb::LandmarkIdMsg* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional uint32 base_camera = 2;
inline bool LandmarkMsg::has_base_camera() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LandmarkMsg::set_has_base_camera() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LandmarkMsg::clear_has_base_camera() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LandmarkMsg::clear_base_camera() {
  base_camera_ = 0u;
  clear_has_base_camera();
}
inline ::google::protobuf::uint32 LandmarkMsg::base_camera() const {
  return base_camera_;
}
inline void LandmarkMsg::set_base_camera(::google::protobuf::uint32 value) {
  set_has_base_camera();
  base_camera_ = value;
}

// optional .pb.DoubleMatrixMsg patch = 3;
inline bool LandmarkMsg::has_patch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LandmarkMsg::set_has_patch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LandmarkMsg::clear_has_patch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LandmarkMsg::clear_patch() {
  if (patch_ != NULL) patch_->::pb::DoubleMatrixMsg::Clear();
  clear_has_patch();
}
inline const ::pb::DoubleMatrixMsg& LandmarkMsg::patch() const {
  return patch_ != NULL ? *patch_ : *default_instance_->patch_;
}
inline ::pb::DoubleMatrixMsg* LandmarkMsg::mutable_patch() {
  set_has_patch();
  if (patch_ == NULL) patch_ = new ::pb::DoubleMatrixMsg;
  return patch_;
}
inline ::pb::DoubleMatrixMsg* LandmarkMsg::release_patch() {
  clear_has_patch();
  ::pb::DoubleMatrixMsg* temp = patch_;
  patch_ = NULL;
  return temp;
}
inline void LandmarkMsg::set_allocated_patch(::pb::DoubleMatrixMsg* patch) {
  delete patch_;
  patch_ = patch;
  if (patch) {
    set_has_patch();
  } else {
    clear_has_patch();
  }
}

// optional bytes feature_descriptor = 4;
inline bool LandmarkMsg::has_feature_descriptor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LandmarkMsg::set_has_feature_descriptor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LandmarkMsg::clear_has_feature_descriptor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LandmarkMsg::clear_feature_descriptor() {
  if (feature_descriptor_ != &::google::protobuf::internal::kEmptyString) {
    feature_descriptor_->clear();
  }
  clear_has_feature_descriptor();
}
inline const ::std::string& LandmarkMsg::feature_descriptor() const {
  return *feature_descriptor_;
}
inline void LandmarkMsg::set_feature_descriptor(const ::std::string& value) {
  set_has_feature_descriptor();
  if (feature_descriptor_ == &::google::protobuf::internal::kEmptyString) {
    feature_descriptor_ = new ::std::string;
  }
  feature_descriptor_->assign(value);
}
inline void LandmarkMsg::set_feature_descriptor(const char* value) {
  set_has_feature_descriptor();
  if (feature_descriptor_ == &::google::protobuf::internal::kEmptyString) {
    feature_descriptor_ = new ::std::string;
  }
  feature_descriptor_->assign(value);
}
inline void LandmarkMsg::set_feature_descriptor(const void* value, size_t size) {
  set_has_feature_descriptor();
  if (feature_descriptor_ == &::google::protobuf::internal::kEmptyString) {
    feature_descriptor_ = new ::std::string;
  }
  feature_descriptor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LandmarkMsg::mutable_feature_descriptor() {
  set_has_feature_descriptor();
  if (feature_descriptor_ == &::google::protobuf::internal::kEmptyString) {
    feature_descriptor_ = new ::std::string;
  }
  return feature_descriptor_;
}
inline ::std::string* LandmarkMsg::release_feature_descriptor() {
  clear_has_feature_descriptor();
  if (feature_descriptor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = feature_descriptor_;
    feature_descriptor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LandmarkMsg::set_allocated_feature_descriptor(::std::string* feature_descriptor) {
  if (feature_descriptor_ != &::google::protobuf::internal::kEmptyString) {
    delete feature_descriptor_;
  }
  if (feature_descriptor) {
    set_has_feature_descriptor();
    feature_descriptor_ = feature_descriptor;
  } else {
    clear_has_feature_descriptor();
    feature_descriptor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .pb.MeasurementIdMsg feature_track = 6;
inline int LandmarkMsg::feature_track_size() const {
  return feature_track_.size();
}
inline void LandmarkMsg::clear_feature_track() {
  feature_track_.Clear();
}
inline const ::pb::MeasurementIdMsg& LandmarkMsg::feature_track(int index) const {
  return feature_track_.Get(index);
}
inline ::pb::MeasurementIdMsg* LandmarkMsg::mutable_feature_track(int index) {
  return feature_track_.Mutable(index);
}
inline ::pb::MeasurementIdMsg* LandmarkMsg::add_feature_track() {
  return feature_track_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::MeasurementIdMsg >&
LandmarkMsg::feature_track() const {
  return feature_track_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::MeasurementIdMsg >*
LandmarkMsg::mutable_feature_track() {
  return &feature_track_;
}

// optional string name = 7;
inline bool LandmarkMsg::has_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LandmarkMsg::set_has_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LandmarkMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LandmarkMsg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LandmarkMsg::name() const {
  return *name_;
}
inline void LandmarkMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LandmarkMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LandmarkMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LandmarkMsg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LandmarkMsg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LandmarkMsg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool active = 8;
inline bool LandmarkMsg::has_active() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LandmarkMsg::set_has_active() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LandmarkMsg::clear_has_active() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LandmarkMsg::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool LandmarkMsg::active() const {
  return active_;
}
inline void LandmarkMsg::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// optional uint32 num_failed_track_attempts = 9;
inline bool LandmarkMsg::has_num_failed_track_attempts() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LandmarkMsg::set_has_num_failed_track_attempts() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LandmarkMsg::clear_has_num_failed_track_attempts() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LandmarkMsg::clear_num_failed_track_attempts() {
  num_failed_track_attempts_ = 0u;
  clear_has_num_failed_track_attempts();
}
inline ::google::protobuf::uint32 LandmarkMsg::num_failed_track_attempts() const {
  return num_failed_track_attempts_;
}
inline void LandmarkMsg::set_num_failed_track_attempts(::google::protobuf::uint32 value) {
  set_has_num_failed_track_attempts();
  num_failed_track_attempts_ = value;
}

// optional uint32 pyramid_level = 10;
inline bool LandmarkMsg::has_pyramid_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LandmarkMsg::set_has_pyramid_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LandmarkMsg::clear_has_pyramid_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LandmarkMsg::clear_pyramid_level() {
  pyramid_level_ = 0u;
  clear_has_pyramid_level();
}
inline ::google::protobuf::uint32 LandmarkMsg::pyramid_level() const {
  return pyramid_level_;
}
inline void LandmarkMsg::set_pyramid_level(::google::protobuf::uint32 value) {
  set_has_pyramid_level();
  pyramid_level_ = value;
}

// optional int32 landmark_state = 11;
inline bool LandmarkMsg::has_landmark_state() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LandmarkMsg::set_has_landmark_state() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LandmarkMsg::clear_has_landmark_state() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LandmarkMsg::clear_landmark_state() {
  landmark_state_ = 0;
  clear_has_landmark_state();
}
inline ::google::protobuf::int32 LandmarkMsg::landmark_state() const {
  return landmark_state_;
}
inline void LandmarkMsg::set_landmark_state(::google::protobuf::int32 value) {
  set_has_landmark_state();
  landmark_state_ = value;
}

// optional double extent = 12;
inline bool LandmarkMsg::has_extent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LandmarkMsg::set_has_extent() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LandmarkMsg::clear_has_extent() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LandmarkMsg::clear_extent() {
  extent_ = 0;
  clear_has_extent();
}
inline double LandmarkMsg::extent() const {
  return extent_;
}
inline void LandmarkMsg::set_extent(double value) {
  set_has_extent();
  extent_ = value;
}

// optional .pb.DoubleMatrixMsg orientation = 13;
inline bool LandmarkMsg::has_orientation() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LandmarkMsg::set_has_orientation() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LandmarkMsg::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LandmarkMsg::clear_orientation() {
  if (orientation_ != NULL) orientation_->::pb::DoubleMatrixMsg::Clear();
  clear_has_orientation();
}
inline const ::pb::DoubleMatrixMsg& LandmarkMsg::orientation() const {
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::pb::DoubleMatrixMsg* LandmarkMsg::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) orientation_ = new ::pb::DoubleMatrixMsg;
  return orientation_;
}
inline ::pb::DoubleMatrixMsg* LandmarkMsg::release_orientation() {
  clear_has_orientation();
  ::pb::DoubleMatrixMsg* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void LandmarkMsg::set_allocated_orientation(::pb::DoubleMatrixMsg* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
}

// optional .pb.DoubleMatrixMsg relative_pos = 14;
inline bool LandmarkMsg::has_relative_pos() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LandmarkMsg::set_has_relative_pos() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LandmarkMsg::clear_has_relative_pos() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LandmarkMsg::clear_relative_pos() {
  if (relative_pos_ != NULL) relative_pos_->::pb::DoubleMatrixMsg::Clear();
  clear_has_relative_pos();
}
inline const ::pb::DoubleMatrixMsg& LandmarkMsg::relative_pos() const {
  return relative_pos_ != NULL ? *relative_pos_ : *default_instance_->relative_pos_;
}
inline ::pb::DoubleMatrixMsg* LandmarkMsg::mutable_relative_pos() {
  set_has_relative_pos();
  if (relative_pos_ == NULL) relative_pos_ = new ::pb::DoubleMatrixMsg;
  return relative_pos_;
}
inline ::pb::DoubleMatrixMsg* LandmarkMsg::release_relative_pos() {
  clear_has_relative_pos();
  ::pb::DoubleMatrixMsg* temp = relative_pos_;
  relative_pos_ = NULL;
  return temp;
}
inline void LandmarkMsg::set_allocated_relative_pos(::pb::DoubleMatrixMsg* relative_pos) {
  delete relative_pos_;
  relative_pos_ = relative_pos;
  if (relative_pos) {
    set_has_relative_pos();
  } else {
    clear_has_relative_pos();
  }
}

// -------------------------------------------------------------------

// TransformEdgeMsg

// optional .pb.TransformEdgeIdMsg id = 1;
inline bool TransformEdgeMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransformEdgeMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransformEdgeMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransformEdgeMsg::clear_id() {
  if (id_ != NULL) id_->::pb::TransformEdgeIdMsg::Clear();
  clear_has_id();
}
inline const ::pb::TransformEdgeIdMsg& TransformEdgeMsg::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pb::TransformEdgeIdMsg* TransformEdgeMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pb::TransformEdgeIdMsg;
  return id_;
}
inline ::pb::TransformEdgeIdMsg* TransformEdgeMsg::release_id() {
  clear_has_id();
  ::pb::TransformEdgeIdMsg* temp = id_;
  id_ = NULL;
  return temp;
}
inline void TransformEdgeMsg::set_allocated_id(::pb::TransformEdgeIdMsg* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional double last_modified_time = 2;
inline bool TransformEdgeMsg::has_last_modified_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransformEdgeMsg::set_has_last_modified_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransformEdgeMsg::clear_has_last_modified_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransformEdgeMsg::clear_last_modified_time() {
  last_modified_time_ = 0;
  clear_has_last_modified_time();
}
inline double TransformEdgeMsg::last_modified_time() const {
  return last_modified_time_;
}
inline void TransformEdgeMsg::set_last_modified_time(double value) {
  set_has_last_modified_time();
  last_modified_time_ = value;
}

// optional .pb.DoubleMatrixMsg transform = 4;
inline bool TransformEdgeMsg::has_transform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransformEdgeMsg::set_has_transform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransformEdgeMsg::clear_has_transform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransformEdgeMsg::clear_transform() {
  if (transform_ != NULL) transform_->::pb::DoubleMatrixMsg::Clear();
  clear_has_transform();
}
inline const ::pb::DoubleMatrixMsg& TransformEdgeMsg::transform() const {
  return transform_ != NULL ? *transform_ : *default_instance_->transform_;
}
inline ::pb::DoubleMatrixMsg* TransformEdgeMsg::mutable_transform() {
  set_has_transform();
  if (transform_ == NULL) transform_ = new ::pb::DoubleMatrixMsg;
  return transform_;
}
inline ::pb::DoubleMatrixMsg* TransformEdgeMsg::release_transform() {
  clear_has_transform();
  ::pb::DoubleMatrixMsg* temp = transform_;
  transform_ = NULL;
  return temp;
}
inline void TransformEdgeMsg::set_allocated_transform(::pb::DoubleMatrixMsg* transform) {
  delete transform_;
  transform_ = transform;
  if (transform) {
    set_has_transform();
  } else {
    clear_has_transform();
  }
}

// optional .pb.DoubleMatrixMsg g = 5;
inline bool TransformEdgeMsg::has_g() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransformEdgeMsg::set_has_g() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransformEdgeMsg::clear_has_g() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransformEdgeMsg::clear_g() {
  if (g_ != NULL) g_->::pb::DoubleMatrixMsg::Clear();
  clear_has_g();
}
inline const ::pb::DoubleMatrixMsg& TransformEdgeMsg::g() const {
  return g_ != NULL ? *g_ : *default_instance_->g_;
}
inline ::pb::DoubleMatrixMsg* TransformEdgeMsg::mutable_g() {
  set_has_g();
  if (g_ == NULL) g_ = new ::pb::DoubleMatrixMsg;
  return g_;
}
inline ::pb::DoubleMatrixMsg* TransformEdgeMsg::release_g() {
  clear_has_g();
  ::pb::DoubleMatrixMsg* temp = g_;
  g_ = NULL;
  return temp;
}
inline void TransformEdgeMsg::set_allocated_g(::pb::DoubleMatrixMsg* g) {
  delete g_;
  g_ = g;
  if (g) {
    set_has_g();
  } else {
    clear_has_g();
  }
}

// optional bool is_broken = 6;
inline bool TransformEdgeMsg::has_is_broken() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransformEdgeMsg::set_has_is_broken() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransformEdgeMsg::clear_has_is_broken() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransformEdgeMsg::clear_is_broken() {
  is_broken_ = false;
  clear_has_is_broken();
}
inline bool TransformEdgeMsg::is_broken() const {
  return is_broken_;
}
inline void TransformEdgeMsg::set_is_broken(bool value) {
  set_has_is_broken();
  is_broken_ = value;
}

// optional bool is_loop_closure = 7;
inline bool TransformEdgeMsg::has_is_loop_closure() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransformEdgeMsg::set_has_is_loop_closure() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransformEdgeMsg::clear_has_is_loop_closure() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransformEdgeMsg::clear_is_loop_closure() {
  is_loop_closure_ = false;
  clear_has_is_loop_closure();
}
inline bool TransformEdgeMsg::is_loop_closure() const {
  return is_loop_closure_;
}
inline void TransformEdgeMsg::set_is_loop_closure(bool value) {
  set_has_is_loop_closure();
  is_loop_closure_ = value;
}

// -------------------------------------------------------------------

// ReferenceFrameMsg

// optional .pb.ReferenceFrameIdMsg id = 1;
inline bool ReferenceFrameMsg::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferenceFrameMsg::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferenceFrameMsg::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferenceFrameMsg::clear_id() {
  if (id_ != NULL) id_->::pb::ReferenceFrameIdMsg::Clear();
  clear_has_id();
}
inline const ::pb::ReferenceFrameIdMsg& ReferenceFrameMsg::id() const {
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::pb::ReferenceFrameIdMsg* ReferenceFrameMsg::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::pb::ReferenceFrameIdMsg;
  return id_;
}
inline ::pb::ReferenceFrameIdMsg* ReferenceFrameMsg::release_id() {
  clear_has_id();
  ::pb::ReferenceFrameIdMsg* temp = id_;
  id_ = NULL;
  return temp;
}
inline void ReferenceFrameMsg::set_allocated_id(::pb::ReferenceFrameIdMsg* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional .pb.TransformEdgeIdMsg parent_edge_id = 2;
inline bool ReferenceFrameMsg::has_parent_edge_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReferenceFrameMsg::set_has_parent_edge_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReferenceFrameMsg::clear_has_parent_edge_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReferenceFrameMsg::clear_parent_edge_id() {
  if (parent_edge_id_ != NULL) parent_edge_id_->::pb::TransformEdgeIdMsg::Clear();
  clear_has_parent_edge_id();
}
inline const ::pb::TransformEdgeIdMsg& ReferenceFrameMsg::parent_edge_id() const {
  return parent_edge_id_ != NULL ? *parent_edge_id_ : *default_instance_->parent_edge_id_;
}
inline ::pb::TransformEdgeIdMsg* ReferenceFrameMsg::mutable_parent_edge_id() {
  set_has_parent_edge_id();
  if (parent_edge_id_ == NULL) parent_edge_id_ = new ::pb::TransformEdgeIdMsg;
  return parent_edge_id_;
}
inline ::pb::TransformEdgeIdMsg* ReferenceFrameMsg::release_parent_edge_id() {
  clear_has_parent_edge_id();
  ::pb::TransformEdgeIdMsg* temp = parent_edge_id_;
  parent_edge_id_ = NULL;
  return temp;
}
inline void ReferenceFrameMsg::set_allocated_parent_edge_id(::pb::TransformEdgeIdMsg* parent_edge_id) {
  delete parent_edge_id_;
  parent_edge_id_ = parent_edge_id;
  if (parent_edge_id) {
    set_has_parent_edge_id();
  } else {
    clear_has_parent_edge_id();
  }
}

// repeated .pb.TransformEdgeIdMsg neighbor_edge_ids = 3;
inline int ReferenceFrameMsg::neighbor_edge_ids_size() const {
  return neighbor_edge_ids_.size();
}
inline void ReferenceFrameMsg::clear_neighbor_edge_ids() {
  neighbor_edge_ids_.Clear();
}
inline const ::pb::TransformEdgeIdMsg& ReferenceFrameMsg::neighbor_edge_ids(int index) const {
  return neighbor_edge_ids_.Get(index);
}
inline ::pb::TransformEdgeIdMsg* ReferenceFrameMsg::mutable_neighbor_edge_ids(int index) {
  return neighbor_edge_ids_.Mutable(index);
}
inline ::pb::TransformEdgeIdMsg* ReferenceFrameMsg::add_neighbor_edge_ids() {
  return neighbor_edge_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TransformEdgeIdMsg >&
ReferenceFrameMsg::neighbor_edge_ids() const {
  return neighbor_edge_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TransformEdgeIdMsg >*
ReferenceFrameMsg::mutable_neighbor_edge_ids() {
  return &neighbor_edge_ids_;
}

// optional double sensor_time = 4;
inline bool ReferenceFrameMsg::has_sensor_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReferenceFrameMsg::set_has_sensor_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReferenceFrameMsg::clear_has_sensor_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReferenceFrameMsg::clear_sensor_time() {
  sensor_time_ = 0;
  clear_has_sensor_time();
}
inline double ReferenceFrameMsg::sensor_time() const {
  return sensor_time_;
}
inline void ReferenceFrameMsg::set_sensor_time(double value) {
  set_has_sensor_time();
  sensor_time_ = value;
}

// optional bool is_isolated = 5;
inline bool ReferenceFrameMsg::has_is_isolated() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReferenceFrameMsg::set_has_is_isolated() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReferenceFrameMsg::clear_has_is_isolated() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReferenceFrameMsg::clear_is_isolated() {
  is_isolated_ = false;
  clear_has_is_isolated();
}
inline bool ReferenceFrameMsg::is_isolated() const {
  return is_isolated_;
}
inline void ReferenceFrameMsg::set_is_isolated(bool value) {
  set_has_is_isolated();
  is_isolated_ = value;
}

// repeated .pb.LandmarkMsg landmarks = 6;
inline int ReferenceFrameMsg::landmarks_size() const {
  return landmarks_.size();
}
inline void ReferenceFrameMsg::clear_landmarks() {
  landmarks_.Clear();
}
inline const ::pb::LandmarkMsg& ReferenceFrameMsg::landmarks(int index) const {
  return landmarks_.Get(index);
}
inline ::pb::LandmarkMsg* ReferenceFrameMsg::mutable_landmarks(int index) {
  return landmarks_.Mutable(index);
}
inline ::pb::LandmarkMsg* ReferenceFrameMsg::add_landmarks() {
  return landmarks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::LandmarkMsg >&
ReferenceFrameMsg::landmarks() const {
  return landmarks_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::LandmarkMsg >*
ReferenceFrameMsg::mutable_landmarks() {
  return &landmarks_;
}

// repeated .pb.MultiViewMeasurementMsg measurements = 7;
inline int ReferenceFrameMsg::measurements_size() const {
  return measurements_.size();
}
inline void ReferenceFrameMsg::clear_measurements() {
  measurements_.Clear();
}
inline const ::pb::MultiViewMeasurementMsg& ReferenceFrameMsg::measurements(int index) const {
  return measurements_.Get(index);
}
inline ::pb::MultiViewMeasurementMsg* ReferenceFrameMsg::mutable_measurements(int index) {
  return measurements_.Mutable(index);
}
inline ::pb::MultiViewMeasurementMsg* ReferenceFrameMsg::add_measurements() {
  return measurements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::MultiViewMeasurementMsg >&
ReferenceFrameMsg::measurements() const {
  return measurements_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::MultiViewMeasurementMsg >*
ReferenceFrameMsg::mutable_measurements() {
  return &measurements_;
}

// optional .pb.DoubleMatrixMsg velocity = 8;
inline bool ReferenceFrameMsg::has_velocity() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReferenceFrameMsg::set_has_velocity() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReferenceFrameMsg::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReferenceFrameMsg::clear_velocity() {
  if (velocity_ != NULL) velocity_->::pb::DoubleMatrixMsg::Clear();
  clear_has_velocity();
}
inline const ::pb::DoubleMatrixMsg& ReferenceFrameMsg::velocity() const {
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::pb::DoubleMatrixMsg* ReferenceFrameMsg::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::pb::DoubleMatrixMsg;
  return velocity_;
}
inline ::pb::DoubleMatrixMsg* ReferenceFrameMsg::release_velocity() {
  clear_has_velocity();
  ::pb::DoubleMatrixMsg* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void ReferenceFrameMsg::set_allocated_velocity(::pb::DoubleMatrixMsg* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
}

// optional double last_modified_time = 9;
inline bool ReferenceFrameMsg::has_last_modified_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReferenceFrameMsg::set_has_last_modified_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReferenceFrameMsg::clear_has_last_modified_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReferenceFrameMsg::clear_last_modified_time() {
  last_modified_time_ = 0;
  clear_has_last_modified_time();
}
inline double ReferenceFrameMsg::last_modified_time() const {
  return last_modified_time_;
}
inline void ReferenceFrameMsg::set_last_modified_time(double value) {
  set_has_last_modified_time();
  last_modified_time_ = value;
}

// repeated .pb.FrameObjectMsg objects = 10;
inline int ReferenceFrameMsg::objects_size() const {
  return objects_.size();
}
inline void ReferenceFrameMsg::clear_objects() {
  objects_.Clear();
}
inline const ::pb::FrameObjectMsg& ReferenceFrameMsg::objects(int index) const {
  return objects_.Get(index);
}
inline ::pb::FrameObjectMsg* ReferenceFrameMsg::mutable_objects(int index) {
  return objects_.Mutable(index);
}
inline ::pb::FrameObjectMsg* ReferenceFrameMsg::add_objects() {
  return objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::FrameObjectMsg >&
ReferenceFrameMsg::objects() const {
  return objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::FrameObjectMsg >*
ReferenceFrameMsg::mutable_objects() {
  return &objects_;
}

// optional .pb.DoubleMatrixMsg gravity = 11;
inline bool ReferenceFrameMsg::has_gravity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ReferenceFrameMsg::set_has_gravity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ReferenceFrameMsg::clear_has_gravity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ReferenceFrameMsg::clear_gravity() {
  if (gravity_ != NULL) gravity_->::pb::DoubleMatrixMsg::Clear();
  clear_has_gravity();
}
inline const ::pb::DoubleMatrixMsg& ReferenceFrameMsg::gravity() const {
  return gravity_ != NULL ? *gravity_ : *default_instance_->gravity_;
}
inline ::pb::DoubleMatrixMsg* ReferenceFrameMsg::mutable_gravity() {
  set_has_gravity();
  if (gravity_ == NULL) gravity_ = new ::pb::DoubleMatrixMsg;
  return gravity_;
}
inline ::pb::DoubleMatrixMsg* ReferenceFrameMsg::release_gravity() {
  clear_has_gravity();
  ::pb::DoubleMatrixMsg* temp = gravity_;
  gravity_ = NULL;
  return temp;
}
inline void ReferenceFrameMsg::set_allocated_gravity(::pb::DoubleMatrixMsg* gravity) {
  delete gravity_;
  gravity_ = gravity;
  if (gravity) {
    set_has_gravity();
  } else {
    clear_has_gravity();
  }
}

// optional .pb.DoubleMatrixMsg biases = 12;
inline bool ReferenceFrameMsg::has_biases() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ReferenceFrameMsg::set_has_biases() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ReferenceFrameMsg::clear_has_biases() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ReferenceFrameMsg::clear_biases() {
  if (biases_ != NULL) biases_->::pb::DoubleMatrixMsg::Clear();
  clear_has_biases();
}
inline const ::pb::DoubleMatrixMsg& ReferenceFrameMsg::biases() const {
  return biases_ != NULL ? *biases_ : *default_instance_->biases_;
}
inline ::pb::DoubleMatrixMsg* ReferenceFrameMsg::mutable_biases() {
  set_has_biases();
  if (biases_ == NULL) biases_ = new ::pb::DoubleMatrixMsg;
  return biases_;
}
inline ::pb::DoubleMatrixMsg* ReferenceFrameMsg::release_biases() {
  clear_has_biases();
  ::pb::DoubleMatrixMsg* temp = biases_;
  biases_ = NULL;
  return temp;
}
inline void ReferenceFrameMsg::set_allocated_biases(::pb::DoubleMatrixMsg* biases) {
  delete biases_;
  biases_ = biases;
  if (biases) {
    set_has_biases();
  } else {
    clear_has_biases();
  }
}

// -------------------------------------------------------------------

// CameraRigMsg

// repeated .pb.CameraModelMsg cameras = 1;
inline int CameraRigMsg::cameras_size() const {
  return cameras_.size();
}
inline void CameraRigMsg::clear_cameras() {
  cameras_.Clear();
}
inline const ::pb::CameraModelMsg& CameraRigMsg::cameras(int index) const {
  return cameras_.Get(index);
}
inline ::pb::CameraModelMsg* CameraRigMsg::mutable_cameras(int index) {
  return cameras_.Mutable(index);
}
inline ::pb::CameraModelMsg* CameraRigMsg::add_cameras() {
  return cameras_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::CameraModelMsg >&
CameraRigMsg::cameras() const {
  return cameras_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::CameraModelMsg >*
CameraRigMsg::mutable_cameras() {
  return &cameras_;
}

// -------------------------------------------------------------------

// SlamMapMsg

// repeated .pb.SessionIdMsg session_ids = 1;
inline int SlamMapMsg::session_ids_size() const {
  return session_ids_.size();
}
inline void SlamMapMsg::clear_session_ids() {
  session_ids_.Clear();
}
inline const ::pb::SessionIdMsg& SlamMapMsg::session_ids(int index) const {
  return session_ids_.Get(index);
}
inline ::pb::SessionIdMsg* SlamMapMsg::mutable_session_ids(int index) {
  return session_ids_.Mutable(index);
}
inline ::pb::SessionIdMsg* SlamMapMsg::add_session_ids() {
  return session_ids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::SessionIdMsg >&
SlamMapMsg::session_ids() const {
  return session_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::SessionIdMsg >*
SlamMapMsg::mutable_session_ids() {
  return &session_ids_;
}

// repeated .pb.CameraRigMsg rigs = 2;
inline int SlamMapMsg::rigs_size() const {
  return rigs_.size();
}
inline void SlamMapMsg::clear_rigs() {
  rigs_.Clear();
}
inline const ::pb::CameraRigMsg& SlamMapMsg::rigs(int index) const {
  return rigs_.Get(index);
}
inline ::pb::CameraRigMsg* SlamMapMsg::mutable_rigs(int index) {
  return rigs_.Mutable(index);
}
inline ::pb::CameraRigMsg* SlamMapMsg::add_rigs() {
  return rigs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::CameraRigMsg >&
SlamMapMsg::rigs() const {
  return rigs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::CameraRigMsg >*
SlamMapMsg::mutable_rigs() {
  return &rigs_;
}

// repeated .pb.ReferenceFrameMsg nodes = 3;
inline int SlamMapMsg::nodes_size() const {
  return nodes_.size();
}
inline void SlamMapMsg::clear_nodes() {
  nodes_.Clear();
}
inline const ::pb::ReferenceFrameMsg& SlamMapMsg::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::pb::ReferenceFrameMsg* SlamMapMsg::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::pb::ReferenceFrameMsg* SlamMapMsg::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ReferenceFrameMsg >&
SlamMapMsg::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ReferenceFrameMsg >*
SlamMapMsg::mutable_nodes() {
  return &nodes_;
}

// repeated .pb.TransformEdgeMsg edges = 4;
inline int SlamMapMsg::edges_size() const {
  return edges_.size();
}
inline void SlamMapMsg::clear_edges() {
  edges_.Clear();
}
inline const ::pb::TransformEdgeMsg& SlamMapMsg::edges(int index) const {
  return edges_.Get(index);
}
inline ::pb::TransformEdgeMsg* SlamMapMsg::mutable_edges(int index) {
  return edges_.Mutable(index);
}
inline ::pb::TransformEdgeMsg* SlamMapMsg::add_edges() {
  return edges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TransformEdgeMsg >&
SlamMapMsg::edges() const {
  return edges_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TransformEdgeMsg >*
SlamMapMsg::mutable_edges() {
  return &edges_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rslam_2eproto__INCLUDED
