// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SceneGraphShapes.proto

#ifndef PROTOBUF_SceneGraphShapes_2eproto__INCLUDED
#define PROTOBUF_SceneGraphShapes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SceneGraphShapes_2eproto();
void protobuf_AssignDesc_SceneGraphShapes_2eproto();
void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

class BoxMsg;
class CylinderMsg;
class SphereMsg;
class PlaneMsg;
class HeightmapMsg;
class MeshMsg;
class LightMsg;
class WaypointMsg;
class SceneGraphMsg;
class RegisterRenderReqMsg;
class RegisterRenderRepMsg;

// ===================================================================

class BoxMsg : public ::google::protobuf::Message {
 public:
  BoxMsg();
  virtual ~BoxMsg();

  BoxMsg(const BoxMsg& from);

  inline BoxMsg& operator=(const BoxMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoxMsg& default_instance();

  void Swap(BoxMsg* other);

  // implements Message ----------------------------------------------

  BoxMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoxMsg& from);
  void MergeFrom(const BoxMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required double x_length = 2;
  inline bool has_x_length() const;
  inline void clear_x_length();
  static const int kXLengthFieldNumber = 2;
  inline double x_length() const;
  inline void set_x_length(double value);

  // required double y_length = 3;
  inline bool has_y_length() const;
  inline void clear_y_length();
  static const int kYLengthFieldNumber = 3;
  inline double y_length() const;
  inline void set_y_length(double value);

  // required double z_length = 4;
  inline bool has_z_length() const;
  inline void clear_z_length();
  static const int kZLengthFieldNumber = 4;
  inline double z_length() const;
  inline void set_z_length(double value);

  // required double mass = 5;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 5;
  inline double mass() const;
  inline void set_mass(double value);

  // repeated double pose = 6 [packed = true];
  inline int pose_size() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 6;
  inline double pose(int index) const;
  inline void set_pose(int index, double value);
  inline void add_pose(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      pose() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_pose();

  // @@protoc_insertion_point(class_scope:pb.BoxMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_x_length();
  inline void clear_has_x_length();
  inline void set_has_y_length();
  inline void clear_has_y_length();
  inline void set_has_z_length();
  inline void clear_has_z_length();
  inline void set_has_mass();
  inline void clear_has_mass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  double x_length_;
  double y_length_;
  double z_length_;
  double mass_;
  ::google::protobuf::RepeatedField< double > pose_;
  mutable int _pose_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SceneGraphShapes_2eproto();
  friend void protobuf_AssignDesc_SceneGraphShapes_2eproto();
  friend void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

  void InitAsDefaultInstance();
  static BoxMsg* default_instance_;
};
// -------------------------------------------------------------------

class CylinderMsg : public ::google::protobuf::Message {
 public:
  CylinderMsg();
  virtual ~CylinderMsg();

  CylinderMsg(const CylinderMsg& from);

  inline CylinderMsg& operator=(const CylinderMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CylinderMsg& default_instance();

  void Swap(CylinderMsg* other);

  // implements Message ----------------------------------------------

  CylinderMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CylinderMsg& from);
  void MergeFrom(const CylinderMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required double radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline double radius() const;
  inline void set_radius(double value);

  // required double height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline double height() const;
  inline void set_height(double value);

  // required double mass = 4;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 4;
  inline double mass() const;
  inline void set_mass(double value);

  // repeated double pose = 5 [packed = true];
  inline int pose_size() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 5;
  inline double pose(int index) const;
  inline void set_pose(int index, double value);
  inline void add_pose(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      pose() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_pose();

  // @@protoc_insertion_point(class_scope:pb.CylinderMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_mass();
  inline void clear_has_mass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  double radius_;
  double height_;
  double mass_;
  ::google::protobuf::RepeatedField< double > pose_;
  mutable int _pose_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_SceneGraphShapes_2eproto();
  friend void protobuf_AssignDesc_SceneGraphShapes_2eproto();
  friend void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

  void InitAsDefaultInstance();
  static CylinderMsg* default_instance_;
};
// -------------------------------------------------------------------

class SphereMsg : public ::google::protobuf::Message {
 public:
  SphereMsg();
  virtual ~SphereMsg();

  SphereMsg(const SphereMsg& from);

  inline SphereMsg& operator=(const SphereMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SphereMsg& default_instance();

  void Swap(SphereMsg* other);

  // implements Message ----------------------------------------------

  SphereMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SphereMsg& from);
  void MergeFrom(const SphereMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required double radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline double radius() const;
  inline void set_radius(double value);

  // required double mass = 3;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 3;
  inline double mass() const;
  inline void set_mass(double value);

  // repeated double pose = 4 [packed = true];
  inline int pose_size() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 4;
  inline double pose(int index) const;
  inline void set_pose(int index, double value);
  inline void add_pose(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      pose() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_pose();

  // @@protoc_insertion_point(class_scope:pb.SphereMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_mass();
  inline void clear_has_mass();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  double radius_;
  double mass_;
  ::google::protobuf::RepeatedField< double > pose_;
  mutable int _pose_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_SceneGraphShapes_2eproto();
  friend void protobuf_AssignDesc_SceneGraphShapes_2eproto();
  friend void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

  void InitAsDefaultInstance();
  static SphereMsg* default_instance_;
};
// -------------------------------------------------------------------

class PlaneMsg : public ::google::protobuf::Message {
 public:
  PlaneMsg();
  virtual ~PlaneMsg();

  PlaneMsg(const PlaneMsg& from);

  inline PlaneMsg& operator=(const PlaneMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaneMsg& default_instance();

  void Swap(PlaneMsg* other);

  // implements Message ----------------------------------------------

  PlaneMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlaneMsg& from);
  void MergeFrom(const PlaneMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated double normal = 2 [packed = true];
  inline int normal_size() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 2;
  inline double normal(int index) const;
  inline void set_normal(int index, double value);
  inline void add_normal(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      normal() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_normal();

  // repeated double pose = 3 [packed = true];
  inline int pose_size() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 3;
  inline double pose(int index) const;
  inline void set_pose(int index, double value);
  inline void add_pose(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      pose() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_pose();

  // @@protoc_insertion_point(class_scope:pb.PlaneMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedField< double > normal_;
  mutable int _normal_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > pose_;
  mutable int _pose_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SceneGraphShapes_2eproto();
  friend void protobuf_AssignDesc_SceneGraphShapes_2eproto();
  friend void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

  void InitAsDefaultInstance();
  static PlaneMsg* default_instance_;
};
// -------------------------------------------------------------------

class HeightmapMsg : public ::google::protobuf::Message {
 public:
  HeightmapMsg();
  virtual ~HeightmapMsg();

  HeightmapMsg(const HeightmapMsg& from);

  inline HeightmapMsg& operator=(const HeightmapMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeightmapMsg& default_instance();

  void Swap(HeightmapMsg* other);

  // implements Message ----------------------------------------------

  HeightmapMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeightmapMsg& from);
  void MergeFrom(const HeightmapMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 row_count = 1;
  inline bool has_row_count() const;
  inline void clear_row_count();
  static const int kRowCountFieldNumber = 1;
  inline ::google::protobuf::int32 row_count() const;
  inline void set_row_count(::google::protobuf::int32 value);

  // required int32 col_count = 2;
  inline bool has_col_count() const;
  inline void clear_col_count();
  static const int kColCountFieldNumber = 2;
  inline ::google::protobuf::int32 col_count() const;
  inline void set_col_count(::google::protobuf::int32 value);

  // repeated double x_data = 3 [packed = true];
  inline int x_data_size() const;
  inline void clear_x_data();
  static const int kXDataFieldNumber = 3;
  inline double x_data(int index) const;
  inline void set_x_data(int index, double value);
  inline void add_x_data(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      x_data() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_x_data();

  // repeated double y_data = 4 [packed = true];
  inline int y_data_size() const;
  inline void clear_y_data();
  static const int kYDataFieldNumber = 4;
  inline double y_data(int index) const;
  inline void set_y_data(int index, double value);
  inline void add_y_data(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      y_data() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_y_data();

  // repeated double z_data = 5 [packed = true];
  inline int z_data_size() const;
  inline void clear_z_data();
  static const int kZDataFieldNumber = 5;
  inline double z_data(int index) const;
  inline void set_z_data(int index, double value);
  inline void add_z_data(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      z_data() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_z_data();

  // @@protoc_insertion_point(class_scope:pb.HeightmapMsg)
 private:
  inline void set_has_row_count();
  inline void clear_has_row_count();
  inline void set_has_col_count();
  inline void clear_has_col_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 row_count_;
  ::google::protobuf::int32 col_count_;
  ::google::protobuf::RepeatedField< double > x_data_;
  mutable int _x_data_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > y_data_;
  mutable int _y_data_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > z_data_;
  mutable int _z_data_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_SceneGraphShapes_2eproto();
  friend void protobuf_AssignDesc_SceneGraphShapes_2eproto();
  friend void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

  void InitAsDefaultInstance();
  static HeightmapMsg* default_instance_;
};
// -------------------------------------------------------------------

class MeshMsg : public ::google::protobuf::Message {
 public:
  MeshMsg();
  virtual ~MeshMsg();

  MeshMsg(const MeshMsg& from);

  inline MeshMsg& operator=(const MeshMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MeshMsg& default_instance();

  void Swap(MeshMsg* other);

  // implements Message ----------------------------------------------

  MeshMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MeshMsg& from);
  void MergeFrom(const MeshMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string file_dir = 2;
  inline bool has_file_dir() const;
  inline void clear_file_dir();
  static const int kFileDirFieldNumber = 2;
  inline const ::std::string& file_dir() const;
  inline void set_file_dir(const ::std::string& value);
  inline void set_file_dir(const char* value);
  inline void set_file_dir(const char* value, size_t size);
  inline ::std::string* mutable_file_dir();
  inline ::std::string* release_file_dir();
  inline void set_allocated_file_dir(::std::string* file_dir);

  // repeated double pose = 3 [packed = true];
  inline int pose_size() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 3;
  inline double pose(int index) const;
  inline void set_pose(int index, double value);
  inline void add_pose(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      pose() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_pose();

  // @@protoc_insertion_point(class_scope:pb.MeshMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_file_dir();
  inline void clear_has_file_dir();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* file_dir_;
  ::google::protobuf::RepeatedField< double > pose_;
  mutable int _pose_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SceneGraphShapes_2eproto();
  friend void protobuf_AssignDesc_SceneGraphShapes_2eproto();
  friend void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

  void InitAsDefaultInstance();
  static MeshMsg* default_instance_;
};
// -------------------------------------------------------------------

class LightMsg : public ::google::protobuf::Message {
 public:
  LightMsg();
  virtual ~LightMsg();

  LightMsg(const LightMsg& from);

  inline LightMsg& operator=(const LightMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LightMsg& default_instance();

  void Swap(LightMsg* other);

  // implements Message ----------------------------------------------

  LightMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LightMsg& from);
  void MergeFrom(const LightMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated double position = 2 [packed = true];
  inline int position_size() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline double position(int index) const;
  inline void set_position(int index, double value);
  inline void add_position(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      position() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_position();

  // @@protoc_insertion_point(class_scope:pb.LightMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedField< double > position_;
  mutable int _position_cached_byte_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SceneGraphShapes_2eproto();
  friend void protobuf_AssignDesc_SceneGraphShapes_2eproto();
  friend void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

  void InitAsDefaultInstance();
  static LightMsg* default_instance_;
};
// -------------------------------------------------------------------

class WaypointMsg : public ::google::protobuf::Message {
 public:
  WaypointMsg();
  virtual ~WaypointMsg();

  WaypointMsg(const WaypointMsg& from);

  inline WaypointMsg& operator=(const WaypointMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WaypointMsg& default_instance();

  void Swap(WaypointMsg* other);

  // implements Message ----------------------------------------------

  WaypointMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WaypointMsg& from);
  void MergeFrom(const WaypointMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated double pose = 2 [packed = true];
  inline int pose_size() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 2;
  inline double pose(int index) const;
  inline void set_pose(int index, double value);
  inline void add_pose(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      pose() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_pose();

  // required double velocity = 3;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  inline double velocity() const;
  inline void set_velocity(double value);

  // @@protoc_insertion_point(class_scope:pb.WaypointMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_velocity();
  inline void clear_has_velocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedField< double > pose_;
  mutable int _pose_cached_byte_size_;
  double velocity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SceneGraphShapes_2eproto();
  friend void protobuf_AssignDesc_SceneGraphShapes_2eproto();
  friend void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

  void InitAsDefaultInstance();
  static WaypointMsg* default_instance_;
};
// -------------------------------------------------------------------

class SceneGraphMsg : public ::google::protobuf::Message {
 public:
  SceneGraphMsg();
  virtual ~SceneGraphMsg();

  SceneGraphMsg(const SceneGraphMsg& from);

  inline SceneGraphMsg& operator=(const SceneGraphMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SceneGraphMsg& default_instance();

  void Swap(SceneGraphMsg* other);

  // implements Message ----------------------------------------------

  SceneGraphMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SceneGraphMsg& from);
  void MergeFrom(const SceneGraphMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional .pb.BoxMsg box = 2;
  inline bool has_box() const;
  inline void clear_box();
  static const int kBoxFieldNumber = 2;
  inline const ::pb::BoxMsg& box() const;
  inline ::pb::BoxMsg* mutable_box();
  inline ::pb::BoxMsg* release_box();
  inline void set_allocated_box(::pb::BoxMsg* box);

  // optional .pb.CylinderMsg cylinder = 3;
  inline bool has_cylinder() const;
  inline void clear_cylinder();
  static const int kCylinderFieldNumber = 3;
  inline const ::pb::CylinderMsg& cylinder() const;
  inline ::pb::CylinderMsg* mutable_cylinder();
  inline ::pb::CylinderMsg* release_cylinder();
  inline void set_allocated_cylinder(::pb::CylinderMsg* cylinder);

  // optional .pb.SphereMsg sphere = 4;
  inline bool has_sphere() const;
  inline void clear_sphere();
  static const int kSphereFieldNumber = 4;
  inline const ::pb::SphereMsg& sphere() const;
  inline ::pb::SphereMsg* mutable_sphere();
  inline ::pb::SphereMsg* release_sphere();
  inline void set_allocated_sphere(::pb::SphereMsg* sphere);

  // optional .pb.PlaneMsg plane = 5;
  inline bool has_plane() const;
  inline void clear_plane();
  static const int kPlaneFieldNumber = 5;
  inline const ::pb::PlaneMsg& plane() const;
  inline ::pb::PlaneMsg* mutable_plane();
  inline ::pb::PlaneMsg* release_plane();
  inline void set_allocated_plane(::pb::PlaneMsg* plane);

  // optional .pb.HeightmapMsg heightmap = 6;
  inline bool has_heightmap() const;
  inline void clear_heightmap();
  static const int kHeightmapFieldNumber = 6;
  inline const ::pb::HeightmapMsg& heightmap() const;
  inline ::pb::HeightmapMsg* mutable_heightmap();
  inline ::pb::HeightmapMsg* release_heightmap();
  inline void set_allocated_heightmap(::pb::HeightmapMsg* heightmap);

  // optional .pb.MeshMsg mesh = 7;
  inline bool has_mesh() const;
  inline void clear_mesh();
  static const int kMeshFieldNumber = 7;
  inline const ::pb::MeshMsg& mesh() const;
  inline ::pb::MeshMsg* mutable_mesh();
  inline ::pb::MeshMsg* release_mesh();
  inline void set_allocated_mesh(::pb::MeshMsg* mesh);

  // optional .pb.LightMsg light = 8;
  inline bool has_light() const;
  inline void clear_light();
  static const int kLightFieldNumber = 8;
  inline const ::pb::LightMsg& light() const;
  inline ::pb::LightMsg* mutable_light();
  inline ::pb::LightMsg* release_light();
  inline void set_allocated_light(::pb::LightMsg* light);

  // optional .pb.WaypointMsg waypoint = 9;
  inline bool has_waypoint() const;
  inline void clear_waypoint();
  static const int kWaypointFieldNumber = 9;
  inline const ::pb::WaypointMsg& waypoint() const;
  inline ::pb::WaypointMsg* mutable_waypoint();
  inline ::pb::WaypointMsg* release_waypoint();
  inline void set_allocated_waypoint(::pb::WaypointMsg* waypoint);

  // @@protoc_insertion_point(class_scope:pb.SceneGraphMsg)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_box();
  inline void clear_has_box();
  inline void set_has_cylinder();
  inline void clear_has_cylinder();
  inline void set_has_sphere();
  inline void clear_has_sphere();
  inline void set_has_plane();
  inline void clear_has_plane();
  inline void set_has_heightmap();
  inline void clear_has_heightmap();
  inline void set_has_mesh();
  inline void clear_has_mesh();
  inline void set_has_light();
  inline void clear_has_light();
  inline void set_has_waypoint();
  inline void clear_has_waypoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double timestamp_;
  ::pb::BoxMsg* box_;
  ::pb::CylinderMsg* cylinder_;
  ::pb::SphereMsg* sphere_;
  ::pb::PlaneMsg* plane_;
  ::pb::HeightmapMsg* heightmap_;
  ::pb::MeshMsg* mesh_;
  ::pb::LightMsg* light_;
  ::pb::WaypointMsg* waypoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_SceneGraphShapes_2eproto();
  friend void protobuf_AssignDesc_SceneGraphShapes_2eproto();
  friend void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

  void InitAsDefaultInstance();
  static SceneGraphMsg* default_instance_;
};
// -------------------------------------------------------------------

class RegisterRenderReqMsg : public ::google::protobuf::Message {
 public:
  RegisterRenderReqMsg();
  virtual ~RegisterRenderReqMsg();

  RegisterRenderReqMsg(const RegisterRenderReqMsg& from);

  inline RegisterRenderReqMsg& operator=(const RegisterRenderReqMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRenderReqMsg& default_instance();

  void Swap(RegisterRenderReqMsg* other);

  // implements Message ----------------------------------------------

  RegisterRenderReqMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterRenderReqMsg& from);
  void MergeFrom(const RegisterRenderReqMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pb.SceneGraphMsg new_objects = 1;
  inline bool has_new_objects() const;
  inline void clear_new_objects();
  static const int kNewObjectsFieldNumber = 1;
  inline const ::pb::SceneGraphMsg& new_objects() const;
  inline ::pb::SceneGraphMsg* mutable_new_objects();
  inline ::pb::SceneGraphMsg* release_new_objects();
  inline void set_allocated_new_objects(::pb::SceneGraphMsg* new_objects);

  // @@protoc_insertion_point(class_scope:pb.RegisterRenderReqMsg)
 private:
  inline void set_has_new_objects();
  inline void clear_has_new_objects();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::SceneGraphMsg* new_objects_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SceneGraphShapes_2eproto();
  friend void protobuf_AssignDesc_SceneGraphShapes_2eproto();
  friend void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

  void InitAsDefaultInstance();
  static RegisterRenderReqMsg* default_instance_;
};
// -------------------------------------------------------------------

class RegisterRenderRepMsg : public ::google::protobuf::Message {
 public:
  RegisterRenderRepMsg();
  virtual ~RegisterRenderRepMsg();

  RegisterRenderRepMsg(const RegisterRenderRepMsg& from);

  inline RegisterRenderRepMsg& operator=(const RegisterRenderRepMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRenderRepMsg& default_instance();

  void Swap(RegisterRenderRepMsg* other);

  // implements Message ----------------------------------------------

  RegisterRenderRepMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterRenderRepMsg& from);
  void MergeFrom(const RegisterRenderRepMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // @@protoc_insertion_point(class_scope:pb.RegisterRenderRepMsg)
 private:
  inline void set_has_success();
  inline void clear_has_success();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool success_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SceneGraphShapes_2eproto();
  friend void protobuf_AssignDesc_SceneGraphShapes_2eproto();
  friend void protobuf_ShutdownFile_SceneGraphShapes_2eproto();

  void InitAsDefaultInstance();
  static RegisterRenderRepMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// BoxMsg

// required string name = 1;
inline bool BoxMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoxMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoxMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoxMsg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BoxMsg::name() const {
  return *name_;
}
inline void BoxMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BoxMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BoxMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BoxMsg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BoxMsg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BoxMsg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double x_length = 2;
inline bool BoxMsg::has_x_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoxMsg::set_has_x_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoxMsg::clear_has_x_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoxMsg::clear_x_length() {
  x_length_ = 0;
  clear_has_x_length();
}
inline double BoxMsg::x_length() const {
  return x_length_;
}
inline void BoxMsg::set_x_length(double value) {
  set_has_x_length();
  x_length_ = value;
}

// required double y_length = 3;
inline bool BoxMsg::has_y_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoxMsg::set_has_y_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoxMsg::clear_has_y_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoxMsg::clear_y_length() {
  y_length_ = 0;
  clear_has_y_length();
}
inline double BoxMsg::y_length() const {
  return y_length_;
}
inline void BoxMsg::set_y_length(double value) {
  set_has_y_length();
  y_length_ = value;
}

// required double z_length = 4;
inline bool BoxMsg::has_z_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoxMsg::set_has_z_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BoxMsg::clear_has_z_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BoxMsg::clear_z_length() {
  z_length_ = 0;
  clear_has_z_length();
}
inline double BoxMsg::z_length() const {
  return z_length_;
}
inline void BoxMsg::set_z_length(double value) {
  set_has_z_length();
  z_length_ = value;
}

// required double mass = 5;
inline bool BoxMsg::has_mass() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BoxMsg::set_has_mass() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BoxMsg::clear_has_mass() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BoxMsg::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline double BoxMsg::mass() const {
  return mass_;
}
inline void BoxMsg::set_mass(double value) {
  set_has_mass();
  mass_ = value;
}

// repeated double pose = 6 [packed = true];
inline int BoxMsg::pose_size() const {
  return pose_.size();
}
inline void BoxMsg::clear_pose() {
  pose_.Clear();
}
inline double BoxMsg::pose(int index) const {
  return pose_.Get(index);
}
inline void BoxMsg::set_pose(int index, double value) {
  pose_.Set(index, value);
}
inline void BoxMsg::add_pose(double value) {
  pose_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
BoxMsg::pose() const {
  return pose_;
}
inline ::google::protobuf::RepeatedField< double >*
BoxMsg::mutable_pose() {
  return &pose_;
}

// -------------------------------------------------------------------

// CylinderMsg

// required string name = 1;
inline bool CylinderMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CylinderMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CylinderMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CylinderMsg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CylinderMsg::name() const {
  return *name_;
}
inline void CylinderMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CylinderMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CylinderMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CylinderMsg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CylinderMsg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CylinderMsg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double radius = 2;
inline bool CylinderMsg::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CylinderMsg::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CylinderMsg::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CylinderMsg::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double CylinderMsg::radius() const {
  return radius_;
}
inline void CylinderMsg::set_radius(double value) {
  set_has_radius();
  radius_ = value;
}

// required double height = 3;
inline bool CylinderMsg::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CylinderMsg::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CylinderMsg::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CylinderMsg::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double CylinderMsg::height() const {
  return height_;
}
inline void CylinderMsg::set_height(double value) {
  set_has_height();
  height_ = value;
}

// required double mass = 4;
inline bool CylinderMsg::has_mass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CylinderMsg::set_has_mass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CylinderMsg::clear_has_mass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CylinderMsg::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline double CylinderMsg::mass() const {
  return mass_;
}
inline void CylinderMsg::set_mass(double value) {
  set_has_mass();
  mass_ = value;
}

// repeated double pose = 5 [packed = true];
inline int CylinderMsg::pose_size() const {
  return pose_.size();
}
inline void CylinderMsg::clear_pose() {
  pose_.Clear();
}
inline double CylinderMsg::pose(int index) const {
  return pose_.Get(index);
}
inline void CylinderMsg::set_pose(int index, double value) {
  pose_.Set(index, value);
}
inline void CylinderMsg::add_pose(double value) {
  pose_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
CylinderMsg::pose() const {
  return pose_;
}
inline ::google::protobuf::RepeatedField< double >*
CylinderMsg::mutable_pose() {
  return &pose_;
}

// -------------------------------------------------------------------

// SphereMsg

// required string name = 1;
inline bool SphereMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SphereMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SphereMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SphereMsg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SphereMsg::name() const {
  return *name_;
}
inline void SphereMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SphereMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SphereMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SphereMsg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SphereMsg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SphereMsg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double radius = 2;
inline bool SphereMsg::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SphereMsg::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SphereMsg::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SphereMsg::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double SphereMsg::radius() const {
  return radius_;
}
inline void SphereMsg::set_radius(double value) {
  set_has_radius();
  radius_ = value;
}

// required double mass = 3;
inline bool SphereMsg::has_mass() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SphereMsg::set_has_mass() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SphereMsg::clear_has_mass() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SphereMsg::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline double SphereMsg::mass() const {
  return mass_;
}
inline void SphereMsg::set_mass(double value) {
  set_has_mass();
  mass_ = value;
}

// repeated double pose = 4 [packed = true];
inline int SphereMsg::pose_size() const {
  return pose_.size();
}
inline void SphereMsg::clear_pose() {
  pose_.Clear();
}
inline double SphereMsg::pose(int index) const {
  return pose_.Get(index);
}
inline void SphereMsg::set_pose(int index, double value) {
  pose_.Set(index, value);
}
inline void SphereMsg::add_pose(double value) {
  pose_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
SphereMsg::pose() const {
  return pose_;
}
inline ::google::protobuf::RepeatedField< double >*
SphereMsg::mutable_pose() {
  return &pose_;
}

// -------------------------------------------------------------------

// PlaneMsg

// required string name = 1;
inline bool PlaneMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlaneMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlaneMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlaneMsg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlaneMsg::name() const {
  return *name_;
}
inline void PlaneMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlaneMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlaneMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlaneMsg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlaneMsg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlaneMsg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated double normal = 2 [packed = true];
inline int PlaneMsg::normal_size() const {
  return normal_.size();
}
inline void PlaneMsg::clear_normal() {
  normal_.Clear();
}
inline double PlaneMsg::normal(int index) const {
  return normal_.Get(index);
}
inline void PlaneMsg::set_normal(int index, double value) {
  normal_.Set(index, value);
}
inline void PlaneMsg::add_normal(double value) {
  normal_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
PlaneMsg::normal() const {
  return normal_;
}
inline ::google::protobuf::RepeatedField< double >*
PlaneMsg::mutable_normal() {
  return &normal_;
}

// repeated double pose = 3 [packed = true];
inline int PlaneMsg::pose_size() const {
  return pose_.size();
}
inline void PlaneMsg::clear_pose() {
  pose_.Clear();
}
inline double PlaneMsg::pose(int index) const {
  return pose_.Get(index);
}
inline void PlaneMsg::set_pose(int index, double value) {
  pose_.Set(index, value);
}
inline void PlaneMsg::add_pose(double value) {
  pose_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
PlaneMsg::pose() const {
  return pose_;
}
inline ::google::protobuf::RepeatedField< double >*
PlaneMsg::mutable_pose() {
  return &pose_;
}

// -------------------------------------------------------------------

// HeightmapMsg

// required int32 row_count = 1;
inline bool HeightmapMsg::has_row_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeightmapMsg::set_has_row_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeightmapMsg::clear_has_row_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeightmapMsg::clear_row_count() {
  row_count_ = 0;
  clear_has_row_count();
}
inline ::google::protobuf::int32 HeightmapMsg::row_count() const {
  return row_count_;
}
inline void HeightmapMsg::set_row_count(::google::protobuf::int32 value) {
  set_has_row_count();
  row_count_ = value;
}

// required int32 col_count = 2;
inline bool HeightmapMsg::has_col_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeightmapMsg::set_has_col_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeightmapMsg::clear_has_col_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeightmapMsg::clear_col_count() {
  col_count_ = 0;
  clear_has_col_count();
}
inline ::google::protobuf::int32 HeightmapMsg::col_count() const {
  return col_count_;
}
inline void HeightmapMsg::set_col_count(::google::protobuf::int32 value) {
  set_has_col_count();
  col_count_ = value;
}

// repeated double x_data = 3 [packed = true];
inline int HeightmapMsg::x_data_size() const {
  return x_data_.size();
}
inline void HeightmapMsg::clear_x_data() {
  x_data_.Clear();
}
inline double HeightmapMsg::x_data(int index) const {
  return x_data_.Get(index);
}
inline void HeightmapMsg::set_x_data(int index, double value) {
  x_data_.Set(index, value);
}
inline void HeightmapMsg::add_x_data(double value) {
  x_data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
HeightmapMsg::x_data() const {
  return x_data_;
}
inline ::google::protobuf::RepeatedField< double >*
HeightmapMsg::mutable_x_data() {
  return &x_data_;
}

// repeated double y_data = 4 [packed = true];
inline int HeightmapMsg::y_data_size() const {
  return y_data_.size();
}
inline void HeightmapMsg::clear_y_data() {
  y_data_.Clear();
}
inline double HeightmapMsg::y_data(int index) const {
  return y_data_.Get(index);
}
inline void HeightmapMsg::set_y_data(int index, double value) {
  y_data_.Set(index, value);
}
inline void HeightmapMsg::add_y_data(double value) {
  y_data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
HeightmapMsg::y_data() const {
  return y_data_;
}
inline ::google::protobuf::RepeatedField< double >*
HeightmapMsg::mutable_y_data() {
  return &y_data_;
}

// repeated double z_data = 5 [packed = true];
inline int HeightmapMsg::z_data_size() const {
  return z_data_.size();
}
inline void HeightmapMsg::clear_z_data() {
  z_data_.Clear();
}
inline double HeightmapMsg::z_data(int index) const {
  return z_data_.Get(index);
}
inline void HeightmapMsg::set_z_data(int index, double value) {
  z_data_.Set(index, value);
}
inline void HeightmapMsg::add_z_data(double value) {
  z_data_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
HeightmapMsg::z_data() const {
  return z_data_;
}
inline ::google::protobuf::RepeatedField< double >*
HeightmapMsg::mutable_z_data() {
  return &z_data_;
}

// -------------------------------------------------------------------

// MeshMsg

// required string name = 1;
inline bool MeshMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeshMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeshMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeshMsg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MeshMsg::name() const {
  return *name_;
}
inline void MeshMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MeshMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MeshMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MeshMsg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MeshMsg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MeshMsg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string file_dir = 2;
inline bool MeshMsg::has_file_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MeshMsg::set_has_file_dir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MeshMsg::clear_has_file_dir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MeshMsg::clear_file_dir() {
  if (file_dir_ != &::google::protobuf::internal::kEmptyString) {
    file_dir_->clear();
  }
  clear_has_file_dir();
}
inline const ::std::string& MeshMsg::file_dir() const {
  return *file_dir_;
}
inline void MeshMsg::set_file_dir(const ::std::string& value) {
  set_has_file_dir();
  if (file_dir_ == &::google::protobuf::internal::kEmptyString) {
    file_dir_ = new ::std::string;
  }
  file_dir_->assign(value);
}
inline void MeshMsg::set_file_dir(const char* value) {
  set_has_file_dir();
  if (file_dir_ == &::google::protobuf::internal::kEmptyString) {
    file_dir_ = new ::std::string;
  }
  file_dir_->assign(value);
}
inline void MeshMsg::set_file_dir(const char* value, size_t size) {
  set_has_file_dir();
  if (file_dir_ == &::google::protobuf::internal::kEmptyString) {
    file_dir_ = new ::std::string;
  }
  file_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MeshMsg::mutable_file_dir() {
  set_has_file_dir();
  if (file_dir_ == &::google::protobuf::internal::kEmptyString) {
    file_dir_ = new ::std::string;
  }
  return file_dir_;
}
inline ::std::string* MeshMsg::release_file_dir() {
  clear_has_file_dir();
  if (file_dir_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_dir_;
    file_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MeshMsg::set_allocated_file_dir(::std::string* file_dir) {
  if (file_dir_ != &::google::protobuf::internal::kEmptyString) {
    delete file_dir_;
  }
  if (file_dir) {
    set_has_file_dir();
    file_dir_ = file_dir;
  } else {
    clear_has_file_dir();
    file_dir_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated double pose = 3 [packed = true];
inline int MeshMsg::pose_size() const {
  return pose_.size();
}
inline void MeshMsg::clear_pose() {
  pose_.Clear();
}
inline double MeshMsg::pose(int index) const {
  return pose_.Get(index);
}
inline void MeshMsg::set_pose(int index, double value) {
  pose_.Set(index, value);
}
inline void MeshMsg::add_pose(double value) {
  pose_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
MeshMsg::pose() const {
  return pose_;
}
inline ::google::protobuf::RepeatedField< double >*
MeshMsg::mutable_pose() {
  return &pose_;
}

// -------------------------------------------------------------------

// LightMsg

// required string name = 1;
inline bool LightMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LightMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LightMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LightMsg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LightMsg::name() const {
  return *name_;
}
inline void LightMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LightMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LightMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LightMsg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LightMsg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LightMsg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated double position = 2 [packed = true];
inline int LightMsg::position_size() const {
  return position_.size();
}
inline void LightMsg::clear_position() {
  position_.Clear();
}
inline double LightMsg::position(int index) const {
  return position_.Get(index);
}
inline void LightMsg::set_position(int index, double value) {
  position_.Set(index, value);
}
inline void LightMsg::add_position(double value) {
  position_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
LightMsg::position() const {
  return position_;
}
inline ::google::protobuf::RepeatedField< double >*
LightMsg::mutable_position() {
  return &position_;
}

// -------------------------------------------------------------------

// WaypointMsg

// required string name = 1;
inline bool WaypointMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WaypointMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WaypointMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WaypointMsg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& WaypointMsg::name() const {
  return *name_;
}
inline void WaypointMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WaypointMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WaypointMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WaypointMsg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* WaypointMsg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WaypointMsg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated double pose = 2 [packed = true];
inline int WaypointMsg::pose_size() const {
  return pose_.size();
}
inline void WaypointMsg::clear_pose() {
  pose_.Clear();
}
inline double WaypointMsg::pose(int index) const {
  return pose_.Get(index);
}
inline void WaypointMsg::set_pose(int index, double value) {
  pose_.Set(index, value);
}
inline void WaypointMsg::add_pose(double value) {
  pose_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
WaypointMsg::pose() const {
  return pose_;
}
inline ::google::protobuf::RepeatedField< double >*
WaypointMsg::mutable_pose() {
  return &pose_;
}

// required double velocity = 3;
inline bool WaypointMsg::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WaypointMsg::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WaypointMsg::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WaypointMsg::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline double WaypointMsg::velocity() const {
  return velocity_;
}
inline void WaypointMsg::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
}

// -------------------------------------------------------------------

// SceneGraphMsg

// optional double timestamp = 1;
inline bool SceneGraphMsg::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SceneGraphMsg::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SceneGraphMsg::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SceneGraphMsg::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double SceneGraphMsg::timestamp() const {
  return timestamp_;
}
inline void SceneGraphMsg::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .pb.BoxMsg box = 2;
inline bool SceneGraphMsg::has_box() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SceneGraphMsg::set_has_box() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SceneGraphMsg::clear_has_box() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SceneGraphMsg::clear_box() {
  if (box_ != NULL) box_->::pb::BoxMsg::Clear();
  clear_has_box();
}
inline const ::pb::BoxMsg& SceneGraphMsg::box() const {
  return box_ != NULL ? *box_ : *default_instance_->box_;
}
inline ::pb::BoxMsg* SceneGraphMsg::mutable_box() {
  set_has_box();
  if (box_ == NULL) box_ = new ::pb::BoxMsg;
  return box_;
}
inline ::pb::BoxMsg* SceneGraphMsg::release_box() {
  clear_has_box();
  ::pb::BoxMsg* temp = box_;
  box_ = NULL;
  return temp;
}
inline void SceneGraphMsg::set_allocated_box(::pb::BoxMsg* box) {
  delete box_;
  box_ = box;
  if (box) {
    set_has_box();
  } else {
    clear_has_box();
  }
}

// optional .pb.CylinderMsg cylinder = 3;
inline bool SceneGraphMsg::has_cylinder() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SceneGraphMsg::set_has_cylinder() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SceneGraphMsg::clear_has_cylinder() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SceneGraphMsg::clear_cylinder() {
  if (cylinder_ != NULL) cylinder_->::pb::CylinderMsg::Clear();
  clear_has_cylinder();
}
inline const ::pb::CylinderMsg& SceneGraphMsg::cylinder() const {
  return cylinder_ != NULL ? *cylinder_ : *default_instance_->cylinder_;
}
inline ::pb::CylinderMsg* SceneGraphMsg::mutable_cylinder() {
  set_has_cylinder();
  if (cylinder_ == NULL) cylinder_ = new ::pb::CylinderMsg;
  return cylinder_;
}
inline ::pb::CylinderMsg* SceneGraphMsg::release_cylinder() {
  clear_has_cylinder();
  ::pb::CylinderMsg* temp = cylinder_;
  cylinder_ = NULL;
  return temp;
}
inline void SceneGraphMsg::set_allocated_cylinder(::pb::CylinderMsg* cylinder) {
  delete cylinder_;
  cylinder_ = cylinder;
  if (cylinder) {
    set_has_cylinder();
  } else {
    clear_has_cylinder();
  }
}

// optional .pb.SphereMsg sphere = 4;
inline bool SceneGraphMsg::has_sphere() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SceneGraphMsg::set_has_sphere() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SceneGraphMsg::clear_has_sphere() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SceneGraphMsg::clear_sphere() {
  if (sphere_ != NULL) sphere_->::pb::SphereMsg::Clear();
  clear_has_sphere();
}
inline const ::pb::SphereMsg& SceneGraphMsg::sphere() const {
  return sphere_ != NULL ? *sphere_ : *default_instance_->sphere_;
}
inline ::pb::SphereMsg* SceneGraphMsg::mutable_sphere() {
  set_has_sphere();
  if (sphere_ == NULL) sphere_ = new ::pb::SphereMsg;
  return sphere_;
}
inline ::pb::SphereMsg* SceneGraphMsg::release_sphere() {
  clear_has_sphere();
  ::pb::SphereMsg* temp = sphere_;
  sphere_ = NULL;
  return temp;
}
inline void SceneGraphMsg::set_allocated_sphere(::pb::SphereMsg* sphere) {
  delete sphere_;
  sphere_ = sphere;
  if (sphere) {
    set_has_sphere();
  } else {
    clear_has_sphere();
  }
}

// optional .pb.PlaneMsg plane = 5;
inline bool SceneGraphMsg::has_plane() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SceneGraphMsg::set_has_plane() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SceneGraphMsg::clear_has_plane() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SceneGraphMsg::clear_plane() {
  if (plane_ != NULL) plane_->::pb::PlaneMsg::Clear();
  clear_has_plane();
}
inline const ::pb::PlaneMsg& SceneGraphMsg::plane() const {
  return plane_ != NULL ? *plane_ : *default_instance_->plane_;
}
inline ::pb::PlaneMsg* SceneGraphMsg::mutable_plane() {
  set_has_plane();
  if (plane_ == NULL) plane_ = new ::pb::PlaneMsg;
  return plane_;
}
inline ::pb::PlaneMsg* SceneGraphMsg::release_plane() {
  clear_has_plane();
  ::pb::PlaneMsg* temp = plane_;
  plane_ = NULL;
  return temp;
}
inline void SceneGraphMsg::set_allocated_plane(::pb::PlaneMsg* plane) {
  delete plane_;
  plane_ = plane;
  if (plane) {
    set_has_plane();
  } else {
    clear_has_plane();
  }
}

// optional .pb.HeightmapMsg heightmap = 6;
inline bool SceneGraphMsg::has_heightmap() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SceneGraphMsg::set_has_heightmap() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SceneGraphMsg::clear_has_heightmap() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SceneGraphMsg::clear_heightmap() {
  if (heightmap_ != NULL) heightmap_->::pb::HeightmapMsg::Clear();
  clear_has_heightmap();
}
inline const ::pb::HeightmapMsg& SceneGraphMsg::heightmap() const {
  return heightmap_ != NULL ? *heightmap_ : *default_instance_->heightmap_;
}
inline ::pb::HeightmapMsg* SceneGraphMsg::mutable_heightmap() {
  set_has_heightmap();
  if (heightmap_ == NULL) heightmap_ = new ::pb::HeightmapMsg;
  return heightmap_;
}
inline ::pb::HeightmapMsg* SceneGraphMsg::release_heightmap() {
  clear_has_heightmap();
  ::pb::HeightmapMsg* temp = heightmap_;
  heightmap_ = NULL;
  return temp;
}
inline void SceneGraphMsg::set_allocated_heightmap(::pb::HeightmapMsg* heightmap) {
  delete heightmap_;
  heightmap_ = heightmap;
  if (heightmap) {
    set_has_heightmap();
  } else {
    clear_has_heightmap();
  }
}

// optional .pb.MeshMsg mesh = 7;
inline bool SceneGraphMsg::has_mesh() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SceneGraphMsg::set_has_mesh() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SceneGraphMsg::clear_has_mesh() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SceneGraphMsg::clear_mesh() {
  if (mesh_ != NULL) mesh_->::pb::MeshMsg::Clear();
  clear_has_mesh();
}
inline const ::pb::MeshMsg& SceneGraphMsg::mesh() const {
  return mesh_ != NULL ? *mesh_ : *default_instance_->mesh_;
}
inline ::pb::MeshMsg* SceneGraphMsg::mutable_mesh() {
  set_has_mesh();
  if (mesh_ == NULL) mesh_ = new ::pb::MeshMsg;
  return mesh_;
}
inline ::pb::MeshMsg* SceneGraphMsg::release_mesh() {
  clear_has_mesh();
  ::pb::MeshMsg* temp = mesh_;
  mesh_ = NULL;
  return temp;
}
inline void SceneGraphMsg::set_allocated_mesh(::pb::MeshMsg* mesh) {
  delete mesh_;
  mesh_ = mesh;
  if (mesh) {
    set_has_mesh();
  } else {
    clear_has_mesh();
  }
}

// optional .pb.LightMsg light = 8;
inline bool SceneGraphMsg::has_light() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SceneGraphMsg::set_has_light() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SceneGraphMsg::clear_has_light() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SceneGraphMsg::clear_light() {
  if (light_ != NULL) light_->::pb::LightMsg::Clear();
  clear_has_light();
}
inline const ::pb::LightMsg& SceneGraphMsg::light() const {
  return light_ != NULL ? *light_ : *default_instance_->light_;
}
inline ::pb::LightMsg* SceneGraphMsg::mutable_light() {
  set_has_light();
  if (light_ == NULL) light_ = new ::pb::LightMsg;
  return light_;
}
inline ::pb::LightMsg* SceneGraphMsg::release_light() {
  clear_has_light();
  ::pb::LightMsg* temp = light_;
  light_ = NULL;
  return temp;
}
inline void SceneGraphMsg::set_allocated_light(::pb::LightMsg* light) {
  delete light_;
  light_ = light;
  if (light) {
    set_has_light();
  } else {
    clear_has_light();
  }
}

// optional .pb.WaypointMsg waypoint = 9;
inline bool SceneGraphMsg::has_waypoint() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SceneGraphMsg::set_has_waypoint() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SceneGraphMsg::clear_has_waypoint() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SceneGraphMsg::clear_waypoint() {
  if (waypoint_ != NULL) waypoint_->::pb::WaypointMsg::Clear();
  clear_has_waypoint();
}
inline const ::pb::WaypointMsg& SceneGraphMsg::waypoint() const {
  return waypoint_ != NULL ? *waypoint_ : *default_instance_->waypoint_;
}
inline ::pb::WaypointMsg* SceneGraphMsg::mutable_waypoint() {
  set_has_waypoint();
  if (waypoint_ == NULL) waypoint_ = new ::pb::WaypointMsg;
  return waypoint_;
}
inline ::pb::WaypointMsg* SceneGraphMsg::release_waypoint() {
  clear_has_waypoint();
  ::pb::WaypointMsg* temp = waypoint_;
  waypoint_ = NULL;
  return temp;
}
inline void SceneGraphMsg::set_allocated_waypoint(::pb::WaypointMsg* waypoint) {
  delete waypoint_;
  waypoint_ = waypoint;
  if (waypoint) {
    set_has_waypoint();
  } else {
    clear_has_waypoint();
  }
}

// -------------------------------------------------------------------

// RegisterRenderReqMsg

// required .pb.SceneGraphMsg new_objects = 1;
inline bool RegisterRenderReqMsg::has_new_objects() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRenderReqMsg::set_has_new_objects() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRenderReqMsg::clear_has_new_objects() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRenderReqMsg::clear_new_objects() {
  if (new_objects_ != NULL) new_objects_->::pb::SceneGraphMsg::Clear();
  clear_has_new_objects();
}
inline const ::pb::SceneGraphMsg& RegisterRenderReqMsg::new_objects() const {
  return new_objects_ != NULL ? *new_objects_ : *default_instance_->new_objects_;
}
inline ::pb::SceneGraphMsg* RegisterRenderReqMsg::mutable_new_objects() {
  set_has_new_objects();
  if (new_objects_ == NULL) new_objects_ = new ::pb::SceneGraphMsg;
  return new_objects_;
}
inline ::pb::SceneGraphMsg* RegisterRenderReqMsg::release_new_objects() {
  clear_has_new_objects();
  ::pb::SceneGraphMsg* temp = new_objects_;
  new_objects_ = NULL;
  return temp;
}
inline void RegisterRenderReqMsg::set_allocated_new_objects(::pb::SceneGraphMsg* new_objects) {
  delete new_objects_;
  new_objects_ = new_objects;
  if (new_objects) {
    set_has_new_objects();
  } else {
    clear_has_new_objects();
  }
}

// -------------------------------------------------------------------

// RegisterRenderRepMsg

// optional bool success = 1;
inline bool RegisterRenderRepMsg::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRenderRepMsg::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRenderRepMsg::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRenderRepMsg::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool RegisterRenderRepMsg::success() const {
  return success_;
}
inline void RegisterRenderRepMsg::set_success(bool value) {
  set_has_success();
  success_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SceneGraphShapes_2eproto__INCLUDED
