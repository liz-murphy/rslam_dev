// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SimMessages.proto

#ifndef PROTOBUF_SimMessages_2eproto__INCLUDED
#define PROTOBUF_SimMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SimMessages_2eproto();
void protobuf_AssignDesc_SimMessages_2eproto();
void protobuf_ShutdownFile_SimMessages_2eproto();

class Vector6Msg;
class Vector3Msg;
class Matrix33Msg;
class BodyStateMsg;
class URDFMsg;
class RegisterLocalSimReqMsg;
class RegisterLocalSimRepMsg;
class LocalSimAddNewRobotReqMsg;
class LocalSimAddNewRobotRepMsg;
class LocalSimDeleteRobotReqMsg;
class LocalSimDeleteRobotRepMsg;
class RobotFullStateMsg;
class WorldFullStateMsg;
class RegisterRobotReqMsg;
class RegisterRobotRepMsg;
class GPSReqMsg;
class GPSMsg;
class NodeCamMsg;
class NodeCamImageMsg;

// ===================================================================

class Vector6Msg : public ::google::protobuf::Message {
 public:
  Vector6Msg();
  virtual ~Vector6Msg();

  Vector6Msg(const Vector6Msg& from);

  inline Vector6Msg& operator=(const Vector6Msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector6Msg& default_instance();

  void Swap(Vector6Msg* other);

  // implements Message ----------------------------------------------

  Vector6Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector6Msg& from);
  void MergeFrom(const Vector6Msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // required double p = 4;
  inline bool has_p() const;
  inline void clear_p();
  static const int kPFieldNumber = 4;
  inline double p() const;
  inline void set_p(double value);

  // required double q = 5;
  inline bool has_q() const;
  inline void clear_q();
  static const int kQFieldNumber = 5;
  inline double q() const;
  inline void set_q(double value);

  // required double r = 6;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 6;
  inline double r() const;
  inline void set_r(double value);

  // @@protoc_insertion_point(class_scope:Vector6Msg)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_p();
  inline void clear_has_p();
  inline void set_has_q();
  inline void clear_has_q();
  inline void set_has_r();
  inline void clear_has_r();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;
  double p_;
  double q_;
  double r_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static Vector6Msg* default_instance_;
};
// -------------------------------------------------------------------

class Vector3Msg : public ::google::protobuf::Message {
 public:
  Vector3Msg();
  virtual ~Vector3Msg();

  Vector3Msg(const Vector3Msg& from);

  inline Vector3Msg& operator=(const Vector3Msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3Msg& default_instance();

  void Swap(Vector3Msg* other);

  // implements Message ----------------------------------------------

  Vector3Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3Msg& from);
  void MergeFrom(const Vector3Msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:Vector3Msg)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static Vector3Msg* default_instance_;
};
// -------------------------------------------------------------------

class Matrix33Msg : public ::google::protobuf::Message {
 public:
  Matrix33Msg();
  virtual ~Matrix33Msg();

  Matrix33Msg(const Matrix33Msg& from);

  inline Matrix33Msg& operator=(const Matrix33Msg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Matrix33Msg& default_instance();

  void Swap(Matrix33Msg* other);

  // implements Message ----------------------------------------------

  Matrix33Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Matrix33Msg& from);
  void MergeFrom(const Matrix33Msg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x11 = 1;
  inline bool has_x11() const;
  inline void clear_x11();
  static const int kX11FieldNumber = 1;
  inline double x11() const;
  inline void set_x11(double value);

  // required double x12 = 2;
  inline bool has_x12() const;
  inline void clear_x12();
  static const int kX12FieldNumber = 2;
  inline double x12() const;
  inline void set_x12(double value);

  // required double x13 = 3;
  inline bool has_x13() const;
  inline void clear_x13();
  static const int kX13FieldNumber = 3;
  inline double x13() const;
  inline void set_x13(double value);

  // required double x21 = 4;
  inline bool has_x21() const;
  inline void clear_x21();
  static const int kX21FieldNumber = 4;
  inline double x21() const;
  inline void set_x21(double value);

  // required double x22 = 5;
  inline bool has_x22() const;
  inline void clear_x22();
  static const int kX22FieldNumber = 5;
  inline double x22() const;
  inline void set_x22(double value);

  // required double x23 = 6;
  inline bool has_x23() const;
  inline void clear_x23();
  static const int kX23FieldNumber = 6;
  inline double x23() const;
  inline void set_x23(double value);

  // required double x31 = 7;
  inline bool has_x31() const;
  inline void clear_x31();
  static const int kX31FieldNumber = 7;
  inline double x31() const;
  inline void set_x31(double value);

  // required double x32 = 8;
  inline bool has_x32() const;
  inline void clear_x32();
  static const int kX32FieldNumber = 8;
  inline double x32() const;
  inline void set_x32(double value);

  // required double x33 = 9;
  inline bool has_x33() const;
  inline void clear_x33();
  static const int kX33FieldNumber = 9;
  inline double x33() const;
  inline void set_x33(double value);

  // @@protoc_insertion_point(class_scope:Matrix33Msg)
 private:
  inline void set_has_x11();
  inline void clear_has_x11();
  inline void set_has_x12();
  inline void clear_has_x12();
  inline void set_has_x13();
  inline void clear_has_x13();
  inline void set_has_x21();
  inline void clear_has_x21();
  inline void set_has_x22();
  inline void clear_has_x22();
  inline void set_has_x23();
  inline void clear_has_x23();
  inline void set_has_x31();
  inline void clear_has_x31();
  inline void set_has_x32();
  inline void clear_has_x32();
  inline void set_has_x33();
  inline void clear_has_x33();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x11_;
  double x12_;
  double x13_;
  double x21_;
  double x22_;
  double x23_;
  double x31_;
  double x32_;
  double x33_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static Matrix33Msg* default_instance_;
};
// -------------------------------------------------------------------

class BodyStateMsg : public ::google::protobuf::Message {
 public:
  BodyStateMsg();
  virtual ~BodyStateMsg();

  BodyStateMsg(const BodyStateMsg& from);

  inline BodyStateMsg& operator=(const BodyStateMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BodyStateMsg& default_instance();

  void Swap(BodyStateMsg* other);

  // implements Message ----------------------------------------------

  BodyStateMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BodyStateMsg& from);
  void MergeFrom(const BodyStateMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string body_name = 1;
  inline bool has_body_name() const;
  inline void clear_body_name();
  static const int kBodyNameFieldNumber = 1;
  inline const ::std::string& body_name() const;
  inline void set_body_name(const ::std::string& value);
  inline void set_body_name(const char* value);
  inline void set_body_name(const char* value, size_t size);
  inline ::std::string* mutable_body_name();
  inline ::std::string* release_body_name();
  inline void set_allocated_body_name(::std::string* body_name);

  // required .Vector3Msg origin = 2;
  inline bool has_origin() const;
  inline void clear_origin();
  static const int kOriginFieldNumber = 2;
  inline const ::Vector3Msg& origin() const;
  inline ::Vector3Msg* mutable_origin();
  inline ::Vector3Msg* release_origin();
  inline void set_allocated_origin(::Vector3Msg* origin);

  // required .Matrix33Msg basis = 3;
  inline bool has_basis() const;
  inline void clear_basis();
  static const int kBasisFieldNumber = 3;
  inline const ::Matrix33Msg& basis() const;
  inline ::Matrix33Msg* mutable_basis();
  inline ::Matrix33Msg* release_basis();
  inline void set_allocated_basis(::Matrix33Msg* basis);

  // optional .Vector3Msg linear_velocity = 4;
  inline bool has_linear_velocity() const;
  inline void clear_linear_velocity();
  static const int kLinearVelocityFieldNumber = 4;
  inline const ::Vector3Msg& linear_velocity() const;
  inline ::Vector3Msg* mutable_linear_velocity();
  inline ::Vector3Msg* release_linear_velocity();
  inline void set_allocated_linear_velocity(::Vector3Msg* linear_velocity);

  // optional .Vector3Msg angular_velocity = 5;
  inline bool has_angular_velocity() const;
  inline void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 5;
  inline const ::Vector3Msg& angular_velocity() const;
  inline ::Vector3Msg* mutable_angular_velocity();
  inline ::Vector3Msg* release_angular_velocity();
  inline void set_allocated_angular_velocity(::Vector3Msg* angular_velocity);

  // @@protoc_insertion_point(class_scope:BodyStateMsg)
 private:
  inline void set_has_body_name();
  inline void clear_has_body_name();
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_basis();
  inline void clear_has_basis();
  inline void set_has_linear_velocity();
  inline void clear_has_linear_velocity();
  inline void set_has_angular_velocity();
  inline void clear_has_angular_velocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* body_name_;
  ::Vector3Msg* origin_;
  ::Matrix33Msg* basis_;
  ::Vector3Msg* linear_velocity_;
  ::Vector3Msg* angular_velocity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static BodyStateMsg* default_instance_;
};
// -------------------------------------------------------------------

class URDFMsg : public ::google::protobuf::Message {
 public:
  URDFMsg();
  virtual ~URDFMsg();

  URDFMsg(const URDFMsg& from);

  inline URDFMsg& operator=(const URDFMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const URDFMsg& default_instance();

  void Swap(URDFMsg* other);

  // implements Message ----------------------------------------------

  URDFMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const URDFMsg& from);
  void MergeFrom(const URDFMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string robot_name = 1;
  inline bool has_robot_name() const;
  inline void clear_robot_name();
  static const int kRobotNameFieldNumber = 1;
  inline const ::std::string& robot_name() const;
  inline void set_robot_name(const ::std::string& value);
  inline void set_robot_name(const char* value);
  inline void set_robot_name(const char* value, size_t size);
  inline ::std::string* mutable_robot_name();
  inline ::std::string* release_robot_name();
  inline void set_allocated_robot_name(::std::string* robot_name);

  // optional bytes xml = 2;
  inline bool has_xml() const;
  inline void clear_xml();
  static const int kXmlFieldNumber = 2;
  inline const ::std::string& xml() const;
  inline void set_xml(const ::std::string& value);
  inline void set_xml(const char* value);
  inline void set_xml(const void* value, size_t size);
  inline ::std::string* mutable_xml();
  inline ::std::string* release_xml();
  inline void set_allocated_xml(::std::string* xml);

  // repeated bytes mesh = 3;
  inline int mesh_size() const;
  inline void clear_mesh();
  static const int kMeshFieldNumber = 3;
  inline const ::std::string& mesh(int index) const;
  inline ::std::string* mutable_mesh(int index);
  inline void set_mesh(int index, const ::std::string& value);
  inline void set_mesh(int index, const char* value);
  inline void set_mesh(int index, const void* value, size_t size);
  inline ::std::string* add_mesh();
  inline void add_mesh(const ::std::string& value);
  inline void add_mesh(const char* value);
  inline void add_mesh(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& mesh() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mesh();

  // @@protoc_insertion_point(class_scope:URDFMsg)
 private:
  inline void set_has_robot_name();
  inline void clear_has_robot_name();
  inline void set_has_xml();
  inline void clear_has_xml();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* robot_name_;
  ::std::string* xml_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mesh_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static URDFMsg* default_instance_;
};
// -------------------------------------------------------------------

class RegisterLocalSimReqMsg : public ::google::protobuf::Message {
 public:
  RegisterLocalSimReqMsg();
  virtual ~RegisterLocalSimReqMsg();

  RegisterLocalSimReqMsg(const RegisterLocalSimReqMsg& from);

  inline RegisterLocalSimReqMsg& operator=(const RegisterLocalSimReqMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterLocalSimReqMsg& default_instance();

  void Swap(RegisterLocalSimReqMsg* other);

  // implements Message ----------------------------------------------

  RegisterLocalSimReqMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterLocalSimReqMsg& from);
  void MergeFrom(const RegisterLocalSimReqMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string proxy_name = 1;
  inline bool has_proxy_name() const;
  inline void clear_proxy_name();
  static const int kProxyNameFieldNumber = 1;
  inline const ::std::string& proxy_name() const;
  inline void set_proxy_name(const ::std::string& value);
  inline void set_proxy_name(const char* value);
  inline void set_proxy_name(const char* value, size_t size);
  inline ::std::string* mutable_proxy_name();
  inline ::std::string* release_proxy_name();
  inline void set_allocated_proxy_name(::std::string* proxy_name);

  // optional .URDFMsg urdf = 2;
  inline bool has_urdf() const;
  inline void clear_urdf();
  static const int kUrdfFieldNumber = 2;
  inline const ::URDFMsg& urdf() const;
  inline ::URDFMsg* mutable_urdf();
  inline ::URDFMsg* release_urdf();
  inline void set_allocated_urdf(::URDFMsg* urdf);

  // @@protoc_insertion_point(class_scope:RegisterLocalSimReqMsg)
 private:
  inline void set_has_proxy_name();
  inline void clear_has_proxy_name();
  inline void set_has_urdf();
  inline void clear_has_urdf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* proxy_name_;
  ::URDFMsg* urdf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static RegisterLocalSimReqMsg* default_instance_;
};
// -------------------------------------------------------------------

class RegisterLocalSimRepMsg : public ::google::protobuf::Message {
 public:
  RegisterLocalSimRepMsg();
  virtual ~RegisterLocalSimRepMsg();

  RegisterLocalSimRepMsg(const RegisterLocalSimRepMsg& from);

  inline RegisterLocalSimRepMsg& operator=(const RegisterLocalSimRepMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterLocalSimRepMsg& default_instance();

  void Swap(RegisterLocalSimRepMsg* other);

  // implements Message ----------------------------------------------

  RegisterLocalSimRepMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterLocalSimRepMsg& from);
  void MergeFrom(const RegisterLocalSimRepMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string robot_name = 1;
  inline bool has_robot_name() const;
  inline void clear_robot_name();
  static const int kRobotNameFieldNumber = 1;
  inline const ::std::string& robot_name() const;
  inline void set_robot_name(const ::std::string& value);
  inline void set_robot_name(const char* value);
  inline void set_robot_name(const char* value, size_t size);
  inline ::std::string* mutable_robot_name();
  inline ::std::string* release_robot_name();
  inline void set_allocated_robot_name(::std::string* robot_name);

  // required int32 time_step = 2;
  inline bool has_time_step() const;
  inline void clear_time_step();
  static const int kTimeStepFieldNumber = 2;
  inline ::google::protobuf::int32 time_step() const;
  inline void set_time_step(::google::protobuf::int32 value);

  // required .Vector6Msg init_pose = 3;
  inline bool has_init_pose() const;
  inline void clear_init_pose();
  static const int kInitPoseFieldNumber = 3;
  inline const ::Vector6Msg& init_pose() const;
  inline ::Vector6Msg* mutable_init_pose();
  inline ::Vector6Msg* release_init_pose();
  inline void set_allocated_init_pose(::Vector6Msg* init_pose);

  // repeated .URDFMsg urdf = 4;
  inline int urdf_size() const;
  inline void clear_urdf();
  static const int kUrdfFieldNumber = 4;
  inline const ::URDFMsg& urdf(int index) const;
  inline ::URDFMsg* mutable_urdf(int index);
  inline ::URDFMsg* add_urdf();
  inline const ::google::protobuf::RepeatedPtrField< ::URDFMsg >&
      urdf() const;
  inline ::google::protobuf::RepeatedPtrField< ::URDFMsg >*
      mutable_urdf();

  // @@protoc_insertion_point(class_scope:RegisterLocalSimRepMsg)
 private:
  inline void set_has_robot_name();
  inline void clear_has_robot_name();
  inline void set_has_time_step();
  inline void clear_has_time_step();
  inline void set_has_init_pose();
  inline void clear_has_init_pose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* robot_name_;
  ::Vector6Msg* init_pose_;
  ::google::protobuf::RepeatedPtrField< ::URDFMsg > urdf_;
  ::google::protobuf::int32 time_step_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static RegisterLocalSimRepMsg* default_instance_;
};
// -------------------------------------------------------------------

class LocalSimAddNewRobotReqMsg : public ::google::protobuf::Message {
 public:
  LocalSimAddNewRobotReqMsg();
  virtual ~LocalSimAddNewRobotReqMsg();

  LocalSimAddNewRobotReqMsg(const LocalSimAddNewRobotReqMsg& from);

  inline LocalSimAddNewRobotReqMsg& operator=(const LocalSimAddNewRobotReqMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalSimAddNewRobotReqMsg& default_instance();

  void Swap(LocalSimAddNewRobotReqMsg* other);

  // implements Message ----------------------------------------------

  LocalSimAddNewRobotReqMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalSimAddNewRobotReqMsg& from);
  void MergeFrom(const LocalSimAddNewRobotReqMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string robot_name = 1;
  inline bool has_robot_name() const;
  inline void clear_robot_name();
  static const int kRobotNameFieldNumber = 1;
  inline const ::std::string& robot_name() const;
  inline void set_robot_name(const ::std::string& value);
  inline void set_robot_name(const char* value);
  inline void set_robot_name(const char* value, size_t size);
  inline ::std::string* mutable_robot_name();
  inline ::std::string* release_robot_name();
  inline void set_allocated_robot_name(::std::string* robot_name);

  // required .URDFMsg urdf = 2;
  inline bool has_urdf() const;
  inline void clear_urdf();
  static const int kUrdfFieldNumber = 2;
  inline const ::URDFMsg& urdf() const;
  inline ::URDFMsg* mutable_urdf();
  inline ::URDFMsg* release_urdf();
  inline void set_allocated_urdf(::URDFMsg* urdf);

  // required .Vector6Msg init_pose = 3;
  inline bool has_init_pose() const;
  inline void clear_init_pose();
  static const int kInitPoseFieldNumber = 3;
  inline const ::Vector6Msg& init_pose() const;
  inline ::Vector6Msg* mutable_init_pose();
  inline ::Vector6Msg* release_init_pose();
  inline void set_allocated_init_pose(::Vector6Msg* init_pose);

  // @@protoc_insertion_point(class_scope:LocalSimAddNewRobotReqMsg)
 private:
  inline void set_has_robot_name();
  inline void clear_has_robot_name();
  inline void set_has_urdf();
  inline void clear_has_urdf();
  inline void set_has_init_pose();
  inline void clear_has_init_pose();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* robot_name_;
  ::URDFMsg* urdf_;
  ::Vector6Msg* init_pose_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static LocalSimAddNewRobotReqMsg* default_instance_;
};
// -------------------------------------------------------------------

class LocalSimAddNewRobotRepMsg : public ::google::protobuf::Message {
 public:
  LocalSimAddNewRobotRepMsg();
  virtual ~LocalSimAddNewRobotRepMsg();

  LocalSimAddNewRobotRepMsg(const LocalSimAddNewRobotRepMsg& from);

  inline LocalSimAddNewRobotRepMsg& operator=(const LocalSimAddNewRobotRepMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalSimAddNewRobotRepMsg& default_instance();

  void Swap(LocalSimAddNewRobotRepMsg* other);

  // implements Message ----------------------------------------------

  LocalSimAddNewRobotRepMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalSimAddNewRobotRepMsg& from);
  void MergeFrom(const LocalSimAddNewRobotRepMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:LocalSimAddNewRobotRepMsg)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static LocalSimAddNewRobotRepMsg* default_instance_;
};
// -------------------------------------------------------------------

class LocalSimDeleteRobotReqMsg : public ::google::protobuf::Message {
 public:
  LocalSimDeleteRobotReqMsg();
  virtual ~LocalSimDeleteRobotReqMsg();

  LocalSimDeleteRobotReqMsg(const LocalSimDeleteRobotReqMsg& from);

  inline LocalSimDeleteRobotReqMsg& operator=(const LocalSimDeleteRobotReqMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalSimDeleteRobotReqMsg& default_instance();

  void Swap(LocalSimDeleteRobotReqMsg* other);

  // implements Message ----------------------------------------------

  LocalSimDeleteRobotReqMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalSimDeleteRobotReqMsg& from);
  void MergeFrom(const LocalSimDeleteRobotReqMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string robot_name = 1;
  inline bool has_robot_name() const;
  inline void clear_robot_name();
  static const int kRobotNameFieldNumber = 1;
  inline const ::std::string& robot_name() const;
  inline void set_robot_name(const ::std::string& value);
  inline void set_robot_name(const char* value);
  inline void set_robot_name(const char* value, size_t size);
  inline ::std::string* mutable_robot_name();
  inline ::std::string* release_robot_name();
  inline void set_allocated_robot_name(::std::string* robot_name);

  // @@protoc_insertion_point(class_scope:LocalSimDeleteRobotReqMsg)
 private:
  inline void set_has_robot_name();
  inline void clear_has_robot_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* robot_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static LocalSimDeleteRobotReqMsg* default_instance_;
};
// -------------------------------------------------------------------

class LocalSimDeleteRobotRepMsg : public ::google::protobuf::Message {
 public:
  LocalSimDeleteRobotRepMsg();
  virtual ~LocalSimDeleteRobotRepMsg();

  LocalSimDeleteRobotRepMsg(const LocalSimDeleteRobotRepMsg& from);

  inline LocalSimDeleteRobotRepMsg& operator=(const LocalSimDeleteRobotRepMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalSimDeleteRobotRepMsg& default_instance();

  void Swap(LocalSimDeleteRobotRepMsg* other);

  // implements Message ----------------------------------------------

  LocalSimDeleteRobotRepMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalSimDeleteRobotRepMsg& from);
  void MergeFrom(const LocalSimDeleteRobotRepMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:LocalSimDeleteRobotRepMsg)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static LocalSimDeleteRobotRepMsg* default_instance_;
};
// -------------------------------------------------------------------

class RobotFullStateMsg : public ::google::protobuf::Message {
 public:
  RobotFullStateMsg();
  virtual ~RobotFullStateMsg();

  RobotFullStateMsg(const RobotFullStateMsg& from);

  inline RobotFullStateMsg& operator=(const RobotFullStateMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotFullStateMsg& default_instance();

  void Swap(RobotFullStateMsg* other);

  // implements Message ----------------------------------------------

  RobotFullStateMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotFullStateMsg& from);
  void MergeFrom(const RobotFullStateMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string robot_name = 1;
  inline bool has_robot_name() const;
  inline void clear_robot_name();
  static const int kRobotNameFieldNumber = 1;
  inline const ::std::string& robot_name() const;
  inline void set_robot_name(const ::std::string& value);
  inline void set_robot_name(const char* value);
  inline void set_robot_name(const char* value, size_t size);
  inline ::std::string* mutable_robot_name();
  inline ::std::string* release_robot_name();
  inline void set_allocated_robot_name(::std::string* robot_name);

  // required int32 time_step = 2;
  inline bool has_time_step() const;
  inline void clear_time_step();
  static const int kTimeStepFieldNumber = 2;
  inline ::google::protobuf::int32 time_step() const;
  inline void set_time_step(::google::protobuf::int32 value);

  // repeated .BodyStateMsg body_state = 3;
  inline int body_state_size() const;
  inline void clear_body_state();
  static const int kBodyStateFieldNumber = 3;
  inline const ::BodyStateMsg& body_state(int index) const;
  inline ::BodyStateMsg* mutable_body_state(int index);
  inline ::BodyStateMsg* add_body_state();
  inline const ::google::protobuf::RepeatedPtrField< ::BodyStateMsg >&
      body_state() const;
  inline ::google::protobuf::RepeatedPtrField< ::BodyStateMsg >*
      mutable_body_state();

  // @@protoc_insertion_point(class_scope:RobotFullStateMsg)
 private:
  inline void set_has_robot_name();
  inline void clear_has_robot_name();
  inline void set_has_time_step();
  inline void clear_has_time_step();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* robot_name_;
  ::google::protobuf::RepeatedPtrField< ::BodyStateMsg > body_state_;
  ::google::protobuf::int32 time_step_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static RobotFullStateMsg* default_instance_;
};
// -------------------------------------------------------------------

class WorldFullStateMsg : public ::google::protobuf::Message {
 public:
  WorldFullStateMsg();
  virtual ~WorldFullStateMsg();

  WorldFullStateMsg(const WorldFullStateMsg& from);

  inline WorldFullStateMsg& operator=(const WorldFullStateMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WorldFullStateMsg& default_instance();

  void Swap(WorldFullStateMsg* other);

  // implements Message ----------------------------------------------

  WorldFullStateMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WorldFullStateMsg& from);
  void MergeFrom(const WorldFullStateMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RobotFullStateMsg robot_state = 1;
  inline int robot_state_size() const;
  inline void clear_robot_state();
  static const int kRobotStateFieldNumber = 1;
  inline const ::RobotFullStateMsg& robot_state(int index) const;
  inline ::RobotFullStateMsg* mutable_robot_state(int index);
  inline ::RobotFullStateMsg* add_robot_state();
  inline const ::google::protobuf::RepeatedPtrField< ::RobotFullStateMsg >&
      robot_state() const;
  inline ::google::protobuf::RepeatedPtrField< ::RobotFullStateMsg >*
      mutable_robot_state();

  // required int32 time_step = 2;
  inline bool has_time_step() const;
  inline void clear_time_step();
  static const int kTimeStepFieldNumber = 2;
  inline ::google::protobuf::int32 time_step() const;
  inline void set_time_step(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:WorldFullStateMsg)
 private:
  inline void set_has_time_step();
  inline void clear_has_time_step();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::RobotFullStateMsg > robot_state_;
  ::google::protobuf::int32 time_step_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static WorldFullStateMsg* default_instance_;
};
// -------------------------------------------------------------------

class RegisterRobotReqMsg : public ::google::protobuf::Message {
 public:
  RegisterRobotReqMsg();
  virtual ~RegisterRobotReqMsg();

  RegisterRobotReqMsg(const RegisterRobotReqMsg& from);

  inline RegisterRobotReqMsg& operator=(const RegisterRobotReqMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRobotReqMsg& default_instance();

  void Swap(RegisterRobotReqMsg* other);

  // implements Message ----------------------------------------------

  RegisterRobotReqMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterRobotReqMsg& from);
  void MergeFrom(const RegisterRobotReqMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:RegisterRobotReqMsg)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static RegisterRobotReqMsg* default_instance_;
};
// -------------------------------------------------------------------

class RegisterRobotRepMsg : public ::google::protobuf::Message {
 public:
  RegisterRobotRepMsg();
  virtual ~RegisterRobotRepMsg();

  RegisterRobotRepMsg(const RegisterRobotRepMsg& from);

  inline RegisterRobotRepMsg& operator=(const RegisterRobotRepMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterRobotRepMsg& default_instance();

  void Swap(RegisterRobotRepMsg* other);

  // implements Message ----------------------------------------------

  RegisterRobotRepMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterRobotRepMsg& from);
  void MergeFrom(const RegisterRobotRepMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:RegisterRobotRepMsg)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static RegisterRobotRepMsg* default_instance_;
};
// -------------------------------------------------------------------

class GPSReqMsg : public ::google::protobuf::Message {
 public:
  GPSReqMsg();
  virtual ~GPSReqMsg();

  GPSReqMsg(const GPSReqMsg& from);

  inline GPSReqMsg& operator=(const GPSReqMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSReqMsg& default_instance();

  void Swap(GPSReqMsg* other);

  // implements Message ----------------------------------------------

  GPSReqMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSReqMsg& from);
  void MergeFrom(const GPSReqMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:GPSReqMsg)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static GPSReqMsg* default_instance_;
};
// -------------------------------------------------------------------

class GPSMsg : public ::google::protobuf::Message {
 public:
  GPSMsg();
  virtual ~GPSMsg();

  GPSMsg(const GPSMsg& from);

  inline GPSMsg& operator=(const GPSMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSMsg& default_instance();

  void Swap(GPSMsg* other);

  // implements Message ----------------------------------------------

  GPSMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSMsg& from);
  void MergeFrom(const GPSMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // required int32 time_step = 4;
  inline bool has_time_step() const;
  inline void clear_time_step();
  static const int kTimeStepFieldNumber = 4;
  inline ::google::protobuf::int32 time_step() const;
  inline void set_time_step(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:GPSMsg)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_time_step();
  inline void clear_has_time_step();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;
  ::google::protobuf::int32 time_step_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static GPSMsg* default_instance_;
};
// -------------------------------------------------------------------

class NodeCamMsg : public ::google::protobuf::Message {
 public:
  NodeCamMsg();
  virtual ~NodeCamMsg();

  NodeCamMsg(const NodeCamMsg& from);

  inline NodeCamMsg& operator=(const NodeCamMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeCamMsg& default_instance();

  void Swap(NodeCamMsg* other);

  // implements Message ----------------------------------------------

  NodeCamMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeCamMsg& from);
  void MergeFrom(const NodeCamMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .NodeCamImageMsg image = 1;
  inline int image_size() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::NodeCamImageMsg& image(int index) const;
  inline ::NodeCamImageMsg* mutable_image(int index);
  inline ::NodeCamImageMsg* add_image();
  inline const ::google::protobuf::RepeatedPtrField< ::NodeCamImageMsg >&
      image() const;
  inline ::google::protobuf::RepeatedPtrField< ::NodeCamImageMsg >*
      mutable_image();

  // required int32 time_step = 2;
  inline bool has_time_step() const;
  inline void clear_time_step();
  static const int kTimeStepFieldNumber = 2;
  inline ::google::protobuf::int32 time_step() const;
  inline void set_time_step(::google::protobuf::int32 value);

  // optional int32 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NodeCamMsg)
 private:
  inline void set_has_time_step();
  inline void clear_has_time_step();
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::NodeCamImageMsg > image_;
  ::google::protobuf::int32 time_step_;
  ::google::protobuf::int32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static NodeCamMsg* default_instance_;
};
// -------------------------------------------------------------------

class NodeCamImageMsg : public ::google::protobuf::Message {
 public:
  NodeCamImageMsg();
  virtual ~NodeCamImageMsg();

  NodeCamImageMsg(const NodeCamImageMsg& from);

  inline NodeCamImageMsg& operator=(const NodeCamImageMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeCamImageMsg& default_instance();

  void Swap(NodeCamImageMsg* other);

  // implements Message ----------------------------------------------

  NodeCamImageMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeCamImageMsg& from);
  void MergeFrom(const NodeCamImageMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes image = 1;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const void* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional int32 image_type = 2;
  inline bool has_image_type() const;
  inline void clear_image_type();
  static const int kImageTypeFieldNumber = 2;
  inline ::google::protobuf::int32 image_type() const;
  inline void set_image_type(::google::protobuf::int32 value);

  // optional int32 image_height = 3;
  inline bool has_image_height() const;
  inline void clear_image_height();
  static const int kImageHeightFieldNumber = 3;
  inline ::google::protobuf::int32 image_height() const;
  inline void set_image_height(::google::protobuf::int32 value);

  // optional int32 image_width = 4;
  inline bool has_image_width() const;
  inline void clear_image_width();
  static const int kImageWidthFieldNumber = 4;
  inline ::google::protobuf::int32 image_width() const;
  inline void set_image_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NodeCamImageMsg)
 private:
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_image_type();
  inline void clear_has_image_type();
  inline void set_has_image_height();
  inline void clear_has_image_height();
  inline void set_has_image_width();
  inline void clear_has_image_width();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* image_;
  ::google::protobuf::int32 image_type_;
  ::google::protobuf::int32 image_height_;
  ::google::protobuf::int32 image_width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_SimMessages_2eproto();
  friend void protobuf_AssignDesc_SimMessages_2eproto();
  friend void protobuf_ShutdownFile_SimMessages_2eproto();

  void InitAsDefaultInstance();
  static NodeCamImageMsg* default_instance_;
};
// ===================================================================


// ===================================================================

// Vector6Msg

// required double x = 1;
inline bool Vector6Msg::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector6Msg::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector6Msg::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector6Msg::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector6Msg::x() const {
  return x_;
}
inline void Vector6Msg::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool Vector6Msg::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector6Msg::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector6Msg::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector6Msg::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector6Msg::y() const {
  return y_;
}
inline void Vector6Msg::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 3;
inline bool Vector6Msg::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector6Msg::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector6Msg::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector6Msg::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector6Msg::z() const {
  return z_;
}
inline void Vector6Msg::set_z(double value) {
  set_has_z();
  z_ = value;
}

// required double p = 4;
inline bool Vector6Msg::has_p() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vector6Msg::set_has_p() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vector6Msg::clear_has_p() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vector6Msg::clear_p() {
  p_ = 0;
  clear_has_p();
}
inline double Vector6Msg::p() const {
  return p_;
}
inline void Vector6Msg::set_p(double value) {
  set_has_p();
  p_ = value;
}

// required double q = 5;
inline bool Vector6Msg::has_q() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Vector6Msg::set_has_q() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Vector6Msg::clear_has_q() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Vector6Msg::clear_q() {
  q_ = 0;
  clear_has_q();
}
inline double Vector6Msg::q() const {
  return q_;
}
inline void Vector6Msg::set_q(double value) {
  set_has_q();
  q_ = value;
}

// required double r = 6;
inline bool Vector6Msg::has_r() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Vector6Msg::set_has_r() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Vector6Msg::clear_has_r() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Vector6Msg::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline double Vector6Msg::r() const {
  return r_;
}
inline void Vector6Msg::set_r(double value) {
  set_has_r();
  r_ = value;
}

// -------------------------------------------------------------------

// Vector3Msg

// required double x = 1;
inline bool Vector3Msg::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3Msg::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3Msg::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3Msg::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector3Msg::x() const {
  return x_;
}
inline void Vector3Msg::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool Vector3Msg::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3Msg::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3Msg::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3Msg::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector3Msg::y() const {
  return y_;
}
inline void Vector3Msg::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 3;
inline bool Vector3Msg::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3Msg::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3Msg::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3Msg::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector3Msg::z() const {
  return z_;
}
inline void Vector3Msg::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// Matrix33Msg

// required double x11 = 1;
inline bool Matrix33Msg::has_x11() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Matrix33Msg::set_has_x11() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Matrix33Msg::clear_has_x11() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Matrix33Msg::clear_x11() {
  x11_ = 0;
  clear_has_x11();
}
inline double Matrix33Msg::x11() const {
  return x11_;
}
inline void Matrix33Msg::set_x11(double value) {
  set_has_x11();
  x11_ = value;
}

// required double x12 = 2;
inline bool Matrix33Msg::has_x12() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Matrix33Msg::set_has_x12() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Matrix33Msg::clear_has_x12() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Matrix33Msg::clear_x12() {
  x12_ = 0;
  clear_has_x12();
}
inline double Matrix33Msg::x12() const {
  return x12_;
}
inline void Matrix33Msg::set_x12(double value) {
  set_has_x12();
  x12_ = value;
}

// required double x13 = 3;
inline bool Matrix33Msg::has_x13() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Matrix33Msg::set_has_x13() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Matrix33Msg::clear_has_x13() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Matrix33Msg::clear_x13() {
  x13_ = 0;
  clear_has_x13();
}
inline double Matrix33Msg::x13() const {
  return x13_;
}
inline void Matrix33Msg::set_x13(double value) {
  set_has_x13();
  x13_ = value;
}

// required double x21 = 4;
inline bool Matrix33Msg::has_x21() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Matrix33Msg::set_has_x21() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Matrix33Msg::clear_has_x21() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Matrix33Msg::clear_x21() {
  x21_ = 0;
  clear_has_x21();
}
inline double Matrix33Msg::x21() const {
  return x21_;
}
inline void Matrix33Msg::set_x21(double value) {
  set_has_x21();
  x21_ = value;
}

// required double x22 = 5;
inline bool Matrix33Msg::has_x22() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Matrix33Msg::set_has_x22() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Matrix33Msg::clear_has_x22() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Matrix33Msg::clear_x22() {
  x22_ = 0;
  clear_has_x22();
}
inline double Matrix33Msg::x22() const {
  return x22_;
}
inline void Matrix33Msg::set_x22(double value) {
  set_has_x22();
  x22_ = value;
}

// required double x23 = 6;
inline bool Matrix33Msg::has_x23() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Matrix33Msg::set_has_x23() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Matrix33Msg::clear_has_x23() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Matrix33Msg::clear_x23() {
  x23_ = 0;
  clear_has_x23();
}
inline double Matrix33Msg::x23() const {
  return x23_;
}
inline void Matrix33Msg::set_x23(double value) {
  set_has_x23();
  x23_ = value;
}

// required double x31 = 7;
inline bool Matrix33Msg::has_x31() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Matrix33Msg::set_has_x31() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Matrix33Msg::clear_has_x31() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Matrix33Msg::clear_x31() {
  x31_ = 0;
  clear_has_x31();
}
inline double Matrix33Msg::x31() const {
  return x31_;
}
inline void Matrix33Msg::set_x31(double value) {
  set_has_x31();
  x31_ = value;
}

// required double x32 = 8;
inline bool Matrix33Msg::has_x32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Matrix33Msg::set_has_x32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Matrix33Msg::clear_has_x32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Matrix33Msg::clear_x32() {
  x32_ = 0;
  clear_has_x32();
}
inline double Matrix33Msg::x32() const {
  return x32_;
}
inline void Matrix33Msg::set_x32(double value) {
  set_has_x32();
  x32_ = value;
}

// required double x33 = 9;
inline bool Matrix33Msg::has_x33() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Matrix33Msg::set_has_x33() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Matrix33Msg::clear_has_x33() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Matrix33Msg::clear_x33() {
  x33_ = 0;
  clear_has_x33();
}
inline double Matrix33Msg::x33() const {
  return x33_;
}
inline void Matrix33Msg::set_x33(double value) {
  set_has_x33();
  x33_ = value;
}

// -------------------------------------------------------------------

// BodyStateMsg

// required string body_name = 1;
inline bool BodyStateMsg::has_body_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BodyStateMsg::set_has_body_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BodyStateMsg::clear_has_body_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BodyStateMsg::clear_body_name() {
  if (body_name_ != &::google::protobuf::internal::kEmptyString) {
    body_name_->clear();
  }
  clear_has_body_name();
}
inline const ::std::string& BodyStateMsg::body_name() const {
  return *body_name_;
}
inline void BodyStateMsg::set_body_name(const ::std::string& value) {
  set_has_body_name();
  if (body_name_ == &::google::protobuf::internal::kEmptyString) {
    body_name_ = new ::std::string;
  }
  body_name_->assign(value);
}
inline void BodyStateMsg::set_body_name(const char* value) {
  set_has_body_name();
  if (body_name_ == &::google::protobuf::internal::kEmptyString) {
    body_name_ = new ::std::string;
  }
  body_name_->assign(value);
}
inline void BodyStateMsg::set_body_name(const char* value, size_t size) {
  set_has_body_name();
  if (body_name_ == &::google::protobuf::internal::kEmptyString) {
    body_name_ = new ::std::string;
  }
  body_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BodyStateMsg::mutable_body_name() {
  set_has_body_name();
  if (body_name_ == &::google::protobuf::internal::kEmptyString) {
    body_name_ = new ::std::string;
  }
  return body_name_;
}
inline ::std::string* BodyStateMsg::release_body_name() {
  clear_has_body_name();
  if (body_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = body_name_;
    body_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BodyStateMsg::set_allocated_body_name(::std::string* body_name) {
  if (body_name_ != &::google::protobuf::internal::kEmptyString) {
    delete body_name_;
  }
  if (body_name) {
    set_has_body_name();
    body_name_ = body_name;
  } else {
    clear_has_body_name();
    body_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Vector3Msg origin = 2;
inline bool BodyStateMsg::has_origin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BodyStateMsg::set_has_origin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BodyStateMsg::clear_has_origin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BodyStateMsg::clear_origin() {
  if (origin_ != NULL) origin_->::Vector3Msg::Clear();
  clear_has_origin();
}
inline const ::Vector3Msg& BodyStateMsg::origin() const {
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::Vector3Msg* BodyStateMsg::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) origin_ = new ::Vector3Msg;
  return origin_;
}
inline ::Vector3Msg* BodyStateMsg::release_origin() {
  clear_has_origin();
  ::Vector3Msg* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void BodyStateMsg::set_allocated_origin(::Vector3Msg* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
}

// required .Matrix33Msg basis = 3;
inline bool BodyStateMsg::has_basis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BodyStateMsg::set_has_basis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BodyStateMsg::clear_has_basis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BodyStateMsg::clear_basis() {
  if (basis_ != NULL) basis_->::Matrix33Msg::Clear();
  clear_has_basis();
}
inline const ::Matrix33Msg& BodyStateMsg::basis() const {
  return basis_ != NULL ? *basis_ : *default_instance_->basis_;
}
inline ::Matrix33Msg* BodyStateMsg::mutable_basis() {
  set_has_basis();
  if (basis_ == NULL) basis_ = new ::Matrix33Msg;
  return basis_;
}
inline ::Matrix33Msg* BodyStateMsg::release_basis() {
  clear_has_basis();
  ::Matrix33Msg* temp = basis_;
  basis_ = NULL;
  return temp;
}
inline void BodyStateMsg::set_allocated_basis(::Matrix33Msg* basis) {
  delete basis_;
  basis_ = basis;
  if (basis) {
    set_has_basis();
  } else {
    clear_has_basis();
  }
}

// optional .Vector3Msg linear_velocity = 4;
inline bool BodyStateMsg::has_linear_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BodyStateMsg::set_has_linear_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BodyStateMsg::clear_has_linear_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BodyStateMsg::clear_linear_velocity() {
  if (linear_velocity_ != NULL) linear_velocity_->::Vector3Msg::Clear();
  clear_has_linear_velocity();
}
inline const ::Vector3Msg& BodyStateMsg::linear_velocity() const {
  return linear_velocity_ != NULL ? *linear_velocity_ : *default_instance_->linear_velocity_;
}
inline ::Vector3Msg* BodyStateMsg::mutable_linear_velocity() {
  set_has_linear_velocity();
  if (linear_velocity_ == NULL) linear_velocity_ = new ::Vector3Msg;
  return linear_velocity_;
}
inline ::Vector3Msg* BodyStateMsg::release_linear_velocity() {
  clear_has_linear_velocity();
  ::Vector3Msg* temp = linear_velocity_;
  linear_velocity_ = NULL;
  return temp;
}
inline void BodyStateMsg::set_allocated_linear_velocity(::Vector3Msg* linear_velocity) {
  delete linear_velocity_;
  linear_velocity_ = linear_velocity;
  if (linear_velocity) {
    set_has_linear_velocity();
  } else {
    clear_has_linear_velocity();
  }
}

// optional .Vector3Msg angular_velocity = 5;
inline bool BodyStateMsg::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BodyStateMsg::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BodyStateMsg::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BodyStateMsg::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->::Vector3Msg::Clear();
  clear_has_angular_velocity();
}
inline const ::Vector3Msg& BodyStateMsg::angular_velocity() const {
  return angular_velocity_ != NULL ? *angular_velocity_ : *default_instance_->angular_velocity_;
}
inline ::Vector3Msg* BodyStateMsg::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) angular_velocity_ = new ::Vector3Msg;
  return angular_velocity_;
}
inline ::Vector3Msg* BodyStateMsg::release_angular_velocity() {
  clear_has_angular_velocity();
  ::Vector3Msg* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline void BodyStateMsg::set_allocated_angular_velocity(::Vector3Msg* angular_velocity) {
  delete angular_velocity_;
  angular_velocity_ = angular_velocity;
  if (angular_velocity) {
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
}

// -------------------------------------------------------------------

// URDFMsg

// optional string robot_name = 1;
inline bool URDFMsg::has_robot_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void URDFMsg::set_has_robot_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void URDFMsg::clear_has_robot_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void URDFMsg::clear_robot_name() {
  if (robot_name_ != &::google::protobuf::internal::kEmptyString) {
    robot_name_->clear();
  }
  clear_has_robot_name();
}
inline const ::std::string& URDFMsg::robot_name() const {
  return *robot_name_;
}
inline void URDFMsg::set_robot_name(const ::std::string& value) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(value);
}
inline void URDFMsg::set_robot_name(const char* value) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(value);
}
inline void URDFMsg::set_robot_name(const char* value, size_t size) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* URDFMsg::mutable_robot_name() {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  return robot_name_;
}
inline ::std::string* URDFMsg::release_robot_name() {
  clear_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = robot_name_;
    robot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void URDFMsg::set_allocated_robot_name(::std::string* robot_name) {
  if (robot_name_ != &::google::protobuf::internal::kEmptyString) {
    delete robot_name_;
  }
  if (robot_name) {
    set_has_robot_name();
    robot_name_ = robot_name;
  } else {
    clear_has_robot_name();
    robot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes xml = 2;
inline bool URDFMsg::has_xml() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void URDFMsg::set_has_xml() {
  _has_bits_[0] |= 0x00000002u;
}
inline void URDFMsg::clear_has_xml() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void URDFMsg::clear_xml() {
  if (xml_ != &::google::protobuf::internal::kEmptyString) {
    xml_->clear();
  }
  clear_has_xml();
}
inline const ::std::string& URDFMsg::xml() const {
  return *xml_;
}
inline void URDFMsg::set_xml(const ::std::string& value) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(value);
}
inline void URDFMsg::set_xml(const char* value) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(value);
}
inline void URDFMsg::set_xml(const void* value, size_t size) {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  xml_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* URDFMsg::mutable_xml() {
  set_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    xml_ = new ::std::string;
  }
  return xml_;
}
inline ::std::string* URDFMsg::release_xml() {
  clear_has_xml();
  if (xml_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xml_;
    xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void URDFMsg::set_allocated_xml(::std::string* xml) {
  if (xml_ != &::google::protobuf::internal::kEmptyString) {
    delete xml_;
  }
  if (xml) {
    set_has_xml();
    xml_ = xml;
  } else {
    clear_has_xml();
    xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated bytes mesh = 3;
inline int URDFMsg::mesh_size() const {
  return mesh_.size();
}
inline void URDFMsg::clear_mesh() {
  mesh_.Clear();
}
inline const ::std::string& URDFMsg::mesh(int index) const {
  return mesh_.Get(index);
}
inline ::std::string* URDFMsg::mutable_mesh(int index) {
  return mesh_.Mutable(index);
}
inline void URDFMsg::set_mesh(int index, const ::std::string& value) {
  mesh_.Mutable(index)->assign(value);
}
inline void URDFMsg::set_mesh(int index, const char* value) {
  mesh_.Mutable(index)->assign(value);
}
inline void URDFMsg::set_mesh(int index, const void* value, size_t size) {
  mesh_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* URDFMsg::add_mesh() {
  return mesh_.Add();
}
inline void URDFMsg::add_mesh(const ::std::string& value) {
  mesh_.Add()->assign(value);
}
inline void URDFMsg::add_mesh(const char* value) {
  mesh_.Add()->assign(value);
}
inline void URDFMsg::add_mesh(const void* value, size_t size) {
  mesh_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
URDFMsg::mesh() const {
  return mesh_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
URDFMsg::mutable_mesh() {
  return &mesh_;
}

// -------------------------------------------------------------------

// RegisterLocalSimReqMsg

// required string proxy_name = 1;
inline bool RegisterLocalSimReqMsg::has_proxy_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterLocalSimReqMsg::set_has_proxy_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterLocalSimReqMsg::clear_has_proxy_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterLocalSimReqMsg::clear_proxy_name() {
  if (proxy_name_ != &::google::protobuf::internal::kEmptyString) {
    proxy_name_->clear();
  }
  clear_has_proxy_name();
}
inline const ::std::string& RegisterLocalSimReqMsg::proxy_name() const {
  return *proxy_name_;
}
inline void RegisterLocalSimReqMsg::set_proxy_name(const ::std::string& value) {
  set_has_proxy_name();
  if (proxy_name_ == &::google::protobuf::internal::kEmptyString) {
    proxy_name_ = new ::std::string;
  }
  proxy_name_->assign(value);
}
inline void RegisterLocalSimReqMsg::set_proxy_name(const char* value) {
  set_has_proxy_name();
  if (proxy_name_ == &::google::protobuf::internal::kEmptyString) {
    proxy_name_ = new ::std::string;
  }
  proxy_name_->assign(value);
}
inline void RegisterLocalSimReqMsg::set_proxy_name(const char* value, size_t size) {
  set_has_proxy_name();
  if (proxy_name_ == &::google::protobuf::internal::kEmptyString) {
    proxy_name_ = new ::std::string;
  }
  proxy_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterLocalSimReqMsg::mutable_proxy_name() {
  set_has_proxy_name();
  if (proxy_name_ == &::google::protobuf::internal::kEmptyString) {
    proxy_name_ = new ::std::string;
  }
  return proxy_name_;
}
inline ::std::string* RegisterLocalSimReqMsg::release_proxy_name() {
  clear_has_proxy_name();
  if (proxy_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proxy_name_;
    proxy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterLocalSimReqMsg::set_allocated_proxy_name(::std::string* proxy_name) {
  if (proxy_name_ != &::google::protobuf::internal::kEmptyString) {
    delete proxy_name_;
  }
  if (proxy_name) {
    set_has_proxy_name();
    proxy_name_ = proxy_name;
  } else {
    clear_has_proxy_name();
    proxy_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .URDFMsg urdf = 2;
inline bool RegisterLocalSimReqMsg::has_urdf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterLocalSimReqMsg::set_has_urdf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterLocalSimReqMsg::clear_has_urdf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterLocalSimReqMsg::clear_urdf() {
  if (urdf_ != NULL) urdf_->::URDFMsg::Clear();
  clear_has_urdf();
}
inline const ::URDFMsg& RegisterLocalSimReqMsg::urdf() const {
  return urdf_ != NULL ? *urdf_ : *default_instance_->urdf_;
}
inline ::URDFMsg* RegisterLocalSimReqMsg::mutable_urdf() {
  set_has_urdf();
  if (urdf_ == NULL) urdf_ = new ::URDFMsg;
  return urdf_;
}
inline ::URDFMsg* RegisterLocalSimReqMsg::release_urdf() {
  clear_has_urdf();
  ::URDFMsg* temp = urdf_;
  urdf_ = NULL;
  return temp;
}
inline void RegisterLocalSimReqMsg::set_allocated_urdf(::URDFMsg* urdf) {
  delete urdf_;
  urdf_ = urdf;
  if (urdf) {
    set_has_urdf();
  } else {
    clear_has_urdf();
  }
}

// -------------------------------------------------------------------

// RegisterLocalSimRepMsg

// required string robot_name = 1;
inline bool RegisterLocalSimRepMsg::has_robot_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterLocalSimRepMsg::set_has_robot_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterLocalSimRepMsg::clear_has_robot_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterLocalSimRepMsg::clear_robot_name() {
  if (robot_name_ != &::google::protobuf::internal::kEmptyString) {
    robot_name_->clear();
  }
  clear_has_robot_name();
}
inline const ::std::string& RegisterLocalSimRepMsg::robot_name() const {
  return *robot_name_;
}
inline void RegisterLocalSimRepMsg::set_robot_name(const ::std::string& value) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(value);
}
inline void RegisterLocalSimRepMsg::set_robot_name(const char* value) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(value);
}
inline void RegisterLocalSimRepMsg::set_robot_name(const char* value, size_t size) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterLocalSimRepMsg::mutable_robot_name() {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  return robot_name_;
}
inline ::std::string* RegisterLocalSimRepMsg::release_robot_name() {
  clear_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = robot_name_;
    robot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterLocalSimRepMsg::set_allocated_robot_name(::std::string* robot_name) {
  if (robot_name_ != &::google::protobuf::internal::kEmptyString) {
    delete robot_name_;
  }
  if (robot_name) {
    set_has_robot_name();
    robot_name_ = robot_name;
  } else {
    clear_has_robot_name();
    robot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 time_step = 2;
inline bool RegisterLocalSimRepMsg::has_time_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterLocalSimRepMsg::set_has_time_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterLocalSimRepMsg::clear_has_time_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterLocalSimRepMsg::clear_time_step() {
  time_step_ = 0;
  clear_has_time_step();
}
inline ::google::protobuf::int32 RegisterLocalSimRepMsg::time_step() const {
  return time_step_;
}
inline void RegisterLocalSimRepMsg::set_time_step(::google::protobuf::int32 value) {
  set_has_time_step();
  time_step_ = value;
}

// required .Vector6Msg init_pose = 3;
inline bool RegisterLocalSimRepMsg::has_init_pose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterLocalSimRepMsg::set_has_init_pose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterLocalSimRepMsg::clear_has_init_pose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterLocalSimRepMsg::clear_init_pose() {
  if (init_pose_ != NULL) init_pose_->::Vector6Msg::Clear();
  clear_has_init_pose();
}
inline const ::Vector6Msg& RegisterLocalSimRepMsg::init_pose() const {
  return init_pose_ != NULL ? *init_pose_ : *default_instance_->init_pose_;
}
inline ::Vector6Msg* RegisterLocalSimRepMsg::mutable_init_pose() {
  set_has_init_pose();
  if (init_pose_ == NULL) init_pose_ = new ::Vector6Msg;
  return init_pose_;
}
inline ::Vector6Msg* RegisterLocalSimRepMsg::release_init_pose() {
  clear_has_init_pose();
  ::Vector6Msg* temp = init_pose_;
  init_pose_ = NULL;
  return temp;
}
inline void RegisterLocalSimRepMsg::set_allocated_init_pose(::Vector6Msg* init_pose) {
  delete init_pose_;
  init_pose_ = init_pose;
  if (init_pose) {
    set_has_init_pose();
  } else {
    clear_has_init_pose();
  }
}

// repeated .URDFMsg urdf = 4;
inline int RegisterLocalSimRepMsg::urdf_size() const {
  return urdf_.size();
}
inline void RegisterLocalSimRepMsg::clear_urdf() {
  urdf_.Clear();
}
inline const ::URDFMsg& RegisterLocalSimRepMsg::urdf(int index) const {
  return urdf_.Get(index);
}
inline ::URDFMsg* RegisterLocalSimRepMsg::mutable_urdf(int index) {
  return urdf_.Mutable(index);
}
inline ::URDFMsg* RegisterLocalSimRepMsg::add_urdf() {
  return urdf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::URDFMsg >&
RegisterLocalSimRepMsg::urdf() const {
  return urdf_;
}
inline ::google::protobuf::RepeatedPtrField< ::URDFMsg >*
RegisterLocalSimRepMsg::mutable_urdf() {
  return &urdf_;
}

// -------------------------------------------------------------------

// LocalSimAddNewRobotReqMsg

// required string robot_name = 1;
inline bool LocalSimAddNewRobotReqMsg::has_robot_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalSimAddNewRobotReqMsg::set_has_robot_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalSimAddNewRobotReqMsg::clear_has_robot_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalSimAddNewRobotReqMsg::clear_robot_name() {
  if (robot_name_ != &::google::protobuf::internal::kEmptyString) {
    robot_name_->clear();
  }
  clear_has_robot_name();
}
inline const ::std::string& LocalSimAddNewRobotReqMsg::robot_name() const {
  return *robot_name_;
}
inline void LocalSimAddNewRobotReqMsg::set_robot_name(const ::std::string& value) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(value);
}
inline void LocalSimAddNewRobotReqMsg::set_robot_name(const char* value) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(value);
}
inline void LocalSimAddNewRobotReqMsg::set_robot_name(const char* value, size_t size) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalSimAddNewRobotReqMsg::mutable_robot_name() {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  return robot_name_;
}
inline ::std::string* LocalSimAddNewRobotReqMsg::release_robot_name() {
  clear_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = robot_name_;
    robot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocalSimAddNewRobotReqMsg::set_allocated_robot_name(::std::string* robot_name) {
  if (robot_name_ != &::google::protobuf::internal::kEmptyString) {
    delete robot_name_;
  }
  if (robot_name) {
    set_has_robot_name();
    robot_name_ = robot_name;
  } else {
    clear_has_robot_name();
    robot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .URDFMsg urdf = 2;
inline bool LocalSimAddNewRobotReqMsg::has_urdf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalSimAddNewRobotReqMsg::set_has_urdf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalSimAddNewRobotReqMsg::clear_has_urdf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalSimAddNewRobotReqMsg::clear_urdf() {
  if (urdf_ != NULL) urdf_->::URDFMsg::Clear();
  clear_has_urdf();
}
inline const ::URDFMsg& LocalSimAddNewRobotReqMsg::urdf() const {
  return urdf_ != NULL ? *urdf_ : *default_instance_->urdf_;
}
inline ::URDFMsg* LocalSimAddNewRobotReqMsg::mutable_urdf() {
  set_has_urdf();
  if (urdf_ == NULL) urdf_ = new ::URDFMsg;
  return urdf_;
}
inline ::URDFMsg* LocalSimAddNewRobotReqMsg::release_urdf() {
  clear_has_urdf();
  ::URDFMsg* temp = urdf_;
  urdf_ = NULL;
  return temp;
}
inline void LocalSimAddNewRobotReqMsg::set_allocated_urdf(::URDFMsg* urdf) {
  delete urdf_;
  urdf_ = urdf;
  if (urdf) {
    set_has_urdf();
  } else {
    clear_has_urdf();
  }
}

// required .Vector6Msg init_pose = 3;
inline bool LocalSimAddNewRobotReqMsg::has_init_pose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalSimAddNewRobotReqMsg::set_has_init_pose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalSimAddNewRobotReqMsg::clear_has_init_pose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalSimAddNewRobotReqMsg::clear_init_pose() {
  if (init_pose_ != NULL) init_pose_->::Vector6Msg::Clear();
  clear_has_init_pose();
}
inline const ::Vector6Msg& LocalSimAddNewRobotReqMsg::init_pose() const {
  return init_pose_ != NULL ? *init_pose_ : *default_instance_->init_pose_;
}
inline ::Vector6Msg* LocalSimAddNewRobotReqMsg::mutable_init_pose() {
  set_has_init_pose();
  if (init_pose_ == NULL) init_pose_ = new ::Vector6Msg;
  return init_pose_;
}
inline ::Vector6Msg* LocalSimAddNewRobotReqMsg::release_init_pose() {
  clear_has_init_pose();
  ::Vector6Msg* temp = init_pose_;
  init_pose_ = NULL;
  return temp;
}
inline void LocalSimAddNewRobotReqMsg::set_allocated_init_pose(::Vector6Msg* init_pose) {
  delete init_pose_;
  init_pose_ = init_pose;
  if (init_pose) {
    set_has_init_pose();
  } else {
    clear_has_init_pose();
  }
}

// -------------------------------------------------------------------

// LocalSimAddNewRobotRepMsg

// optional string message = 1;
inline bool LocalSimAddNewRobotRepMsg::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalSimAddNewRobotRepMsg::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalSimAddNewRobotRepMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalSimAddNewRobotRepMsg::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& LocalSimAddNewRobotRepMsg::message() const {
  return *message_;
}
inline void LocalSimAddNewRobotRepMsg::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void LocalSimAddNewRobotRepMsg::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void LocalSimAddNewRobotRepMsg::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalSimAddNewRobotRepMsg::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* LocalSimAddNewRobotRepMsg::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocalSimAddNewRobotRepMsg::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LocalSimDeleteRobotReqMsg

// required string robot_name = 1;
inline bool LocalSimDeleteRobotReqMsg::has_robot_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalSimDeleteRobotReqMsg::set_has_robot_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalSimDeleteRobotReqMsg::clear_has_robot_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalSimDeleteRobotReqMsg::clear_robot_name() {
  if (robot_name_ != &::google::protobuf::internal::kEmptyString) {
    robot_name_->clear();
  }
  clear_has_robot_name();
}
inline const ::std::string& LocalSimDeleteRobotReqMsg::robot_name() const {
  return *robot_name_;
}
inline void LocalSimDeleteRobotReqMsg::set_robot_name(const ::std::string& value) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(value);
}
inline void LocalSimDeleteRobotReqMsg::set_robot_name(const char* value) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(value);
}
inline void LocalSimDeleteRobotReqMsg::set_robot_name(const char* value, size_t size) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalSimDeleteRobotReqMsg::mutable_robot_name() {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  return robot_name_;
}
inline ::std::string* LocalSimDeleteRobotReqMsg::release_robot_name() {
  clear_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = robot_name_;
    robot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocalSimDeleteRobotReqMsg::set_allocated_robot_name(::std::string* robot_name) {
  if (robot_name_ != &::google::protobuf::internal::kEmptyString) {
    delete robot_name_;
  }
  if (robot_name) {
    set_has_robot_name();
    robot_name_ = robot_name;
  } else {
    clear_has_robot_name();
    robot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LocalSimDeleteRobotRepMsg

// optional string message = 1;
inline bool LocalSimDeleteRobotRepMsg::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalSimDeleteRobotRepMsg::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalSimDeleteRobotRepMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalSimDeleteRobotRepMsg::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& LocalSimDeleteRobotRepMsg::message() const {
  return *message_;
}
inline void LocalSimDeleteRobotRepMsg::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void LocalSimDeleteRobotRepMsg::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void LocalSimDeleteRobotRepMsg::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalSimDeleteRobotRepMsg::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* LocalSimDeleteRobotRepMsg::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocalSimDeleteRobotRepMsg::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RobotFullStateMsg

// required string robot_name = 1;
inline bool RobotFullStateMsg::has_robot_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotFullStateMsg::set_has_robot_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotFullStateMsg::clear_has_robot_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotFullStateMsg::clear_robot_name() {
  if (robot_name_ != &::google::protobuf::internal::kEmptyString) {
    robot_name_->clear();
  }
  clear_has_robot_name();
}
inline const ::std::string& RobotFullStateMsg::robot_name() const {
  return *robot_name_;
}
inline void RobotFullStateMsg::set_robot_name(const ::std::string& value) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(value);
}
inline void RobotFullStateMsg::set_robot_name(const char* value) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(value);
}
inline void RobotFullStateMsg::set_robot_name(const char* value, size_t size) {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  robot_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RobotFullStateMsg::mutable_robot_name() {
  set_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    robot_name_ = new ::std::string;
  }
  return robot_name_;
}
inline ::std::string* RobotFullStateMsg::release_robot_name() {
  clear_has_robot_name();
  if (robot_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = robot_name_;
    robot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RobotFullStateMsg::set_allocated_robot_name(::std::string* robot_name) {
  if (robot_name_ != &::google::protobuf::internal::kEmptyString) {
    delete robot_name_;
  }
  if (robot_name) {
    set_has_robot_name();
    robot_name_ = robot_name;
  } else {
    clear_has_robot_name();
    robot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 time_step = 2;
inline bool RobotFullStateMsg::has_time_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotFullStateMsg::set_has_time_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotFullStateMsg::clear_has_time_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotFullStateMsg::clear_time_step() {
  time_step_ = 0;
  clear_has_time_step();
}
inline ::google::protobuf::int32 RobotFullStateMsg::time_step() const {
  return time_step_;
}
inline void RobotFullStateMsg::set_time_step(::google::protobuf::int32 value) {
  set_has_time_step();
  time_step_ = value;
}

// repeated .BodyStateMsg body_state = 3;
inline int RobotFullStateMsg::body_state_size() const {
  return body_state_.size();
}
inline void RobotFullStateMsg::clear_body_state() {
  body_state_.Clear();
}
inline const ::BodyStateMsg& RobotFullStateMsg::body_state(int index) const {
  return body_state_.Get(index);
}
inline ::BodyStateMsg* RobotFullStateMsg::mutable_body_state(int index) {
  return body_state_.Mutable(index);
}
inline ::BodyStateMsg* RobotFullStateMsg::add_body_state() {
  return body_state_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BodyStateMsg >&
RobotFullStateMsg::body_state() const {
  return body_state_;
}
inline ::google::protobuf::RepeatedPtrField< ::BodyStateMsg >*
RobotFullStateMsg::mutable_body_state() {
  return &body_state_;
}

// -------------------------------------------------------------------

// WorldFullStateMsg

// repeated .RobotFullStateMsg robot_state = 1;
inline int WorldFullStateMsg::robot_state_size() const {
  return robot_state_.size();
}
inline void WorldFullStateMsg::clear_robot_state() {
  robot_state_.Clear();
}
inline const ::RobotFullStateMsg& WorldFullStateMsg::robot_state(int index) const {
  return robot_state_.Get(index);
}
inline ::RobotFullStateMsg* WorldFullStateMsg::mutable_robot_state(int index) {
  return robot_state_.Mutable(index);
}
inline ::RobotFullStateMsg* WorldFullStateMsg::add_robot_state() {
  return robot_state_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RobotFullStateMsg >&
WorldFullStateMsg::robot_state() const {
  return robot_state_;
}
inline ::google::protobuf::RepeatedPtrField< ::RobotFullStateMsg >*
WorldFullStateMsg::mutable_robot_state() {
  return &robot_state_;
}

// required int32 time_step = 2;
inline bool WorldFullStateMsg::has_time_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WorldFullStateMsg::set_has_time_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WorldFullStateMsg::clear_has_time_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WorldFullStateMsg::clear_time_step() {
  time_step_ = 0;
  clear_has_time_step();
}
inline ::google::protobuf::int32 WorldFullStateMsg::time_step() const {
  return time_step_;
}
inline void WorldFullStateMsg::set_time_step(::google::protobuf::int32 value) {
  set_has_time_step();
  time_step_ = value;
}

// -------------------------------------------------------------------

// RegisterRobotReqMsg

// required string name = 1;
inline bool RegisterRobotReqMsg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRobotReqMsg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRobotReqMsg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRobotReqMsg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RegisterRobotReqMsg::name() const {
  return *name_;
}
inline void RegisterRobotReqMsg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegisterRobotReqMsg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RegisterRobotReqMsg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRobotReqMsg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RegisterRobotReqMsg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRobotReqMsg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegisterRobotRepMsg

// optional string message = 1;
inline bool RegisterRobotRepMsg::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterRobotRepMsg::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterRobotRepMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterRobotRepMsg::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& RegisterRobotRepMsg::message() const {
  return *message_;
}
inline void RegisterRobotRepMsg::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void RegisterRobotRepMsg::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void RegisterRobotRepMsg::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterRobotRepMsg::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* RegisterRobotRepMsg::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegisterRobotRepMsg::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GPSReqMsg

// required string message = 1;
inline bool GPSReqMsg::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSReqMsg::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSReqMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSReqMsg::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& GPSReqMsg::message() const {
  return *message_;
}
inline void GPSReqMsg::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void GPSReqMsg::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void GPSReqMsg::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSReqMsg::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* GPSReqMsg::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GPSReqMsg::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GPSMsg

// required double x = 1;
inline bool GPSMsg::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSMsg::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSMsg::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSMsg::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double GPSMsg::x() const {
  return x_;
}
inline void GPSMsg::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool GPSMsg::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPSMsg::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPSMsg::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPSMsg::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double GPSMsg::y() const {
  return y_;
}
inline void GPSMsg::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 3;
inline bool GPSMsg::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPSMsg::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPSMsg::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPSMsg::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double GPSMsg::z() const {
  return z_;
}
inline void GPSMsg::set_z(double value) {
  set_has_z();
  z_ = value;
}

// required int32 time_step = 4;
inline bool GPSMsg::has_time_step() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPSMsg::set_has_time_step() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPSMsg::clear_has_time_step() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPSMsg::clear_time_step() {
  time_step_ = 0;
  clear_has_time_step();
}
inline ::google::protobuf::int32 GPSMsg::time_step() const {
  return time_step_;
}
inline void GPSMsg::set_time_step(::google::protobuf::int32 value) {
  set_has_time_step();
  time_step_ = value;
}

// -------------------------------------------------------------------

// NodeCamMsg

// repeated .NodeCamImageMsg image = 1;
inline int NodeCamMsg::image_size() const {
  return image_.size();
}
inline void NodeCamMsg::clear_image() {
  image_.Clear();
}
inline const ::NodeCamImageMsg& NodeCamMsg::image(int index) const {
  return image_.Get(index);
}
inline ::NodeCamImageMsg* NodeCamMsg::mutable_image(int index) {
  return image_.Mutable(index);
}
inline ::NodeCamImageMsg* NodeCamMsg::add_image() {
  return image_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NodeCamImageMsg >&
NodeCamMsg::image() const {
  return image_;
}
inline ::google::protobuf::RepeatedPtrField< ::NodeCamImageMsg >*
NodeCamMsg::mutable_image() {
  return &image_;
}

// required int32 time_step = 2;
inline bool NodeCamMsg::has_time_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeCamMsg::set_has_time_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeCamMsg::clear_has_time_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeCamMsg::clear_time_step() {
  time_step_ = 0;
  clear_has_time_step();
}
inline ::google::protobuf::int32 NodeCamMsg::time_step() const {
  return time_step_;
}
inline void NodeCamMsg::set_time_step(::google::protobuf::int32 value) {
  set_has_time_step();
  time_step_ = value;
}

// optional int32 size = 3;
inline bool NodeCamMsg::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeCamMsg::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeCamMsg::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeCamMsg::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 NodeCamMsg::size() const {
  return size_;
}
inline void NodeCamMsg::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// NodeCamImageMsg

// optional bytes image = 1;
inline bool NodeCamImageMsg::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeCamImageMsg::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeCamImageMsg::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeCamImageMsg::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& NodeCamImageMsg::image() const {
  return *image_;
}
inline void NodeCamImageMsg::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void NodeCamImageMsg::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void NodeCamImageMsg::set_image(const void* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeCamImageMsg::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* NodeCamImageMsg::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeCamImageMsg::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 image_type = 2;
inline bool NodeCamImageMsg::has_image_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeCamImageMsg::set_has_image_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeCamImageMsg::clear_has_image_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeCamImageMsg::clear_image_type() {
  image_type_ = 0;
  clear_has_image_type();
}
inline ::google::protobuf::int32 NodeCamImageMsg::image_type() const {
  return image_type_;
}
inline void NodeCamImageMsg::set_image_type(::google::protobuf::int32 value) {
  set_has_image_type();
  image_type_ = value;
}

// optional int32 image_height = 3;
inline bool NodeCamImageMsg::has_image_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeCamImageMsg::set_has_image_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeCamImageMsg::clear_has_image_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeCamImageMsg::clear_image_height() {
  image_height_ = 0;
  clear_has_image_height();
}
inline ::google::protobuf::int32 NodeCamImageMsg::image_height() const {
  return image_height_;
}
inline void NodeCamImageMsg::set_image_height(::google::protobuf::int32 value) {
  set_has_image_height();
  image_height_ = value;
}

// optional int32 image_width = 4;
inline bool NodeCamImageMsg::has_image_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeCamImageMsg::set_has_image_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeCamImageMsg::clear_has_image_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeCamImageMsg::clear_image_width() {
  image_width_ = 0;
  clear_has_image_width();
}
inline ::google::protobuf::int32 NodeCamImageMsg::image_width() const {
  return image_width_;
}
inline void NodeCamImageMsg::set_image_width(::google::protobuf::int32 value) {
  set_has_image_width();
  image_width_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SimMessages_2eproto__INCLUDED
