// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NodeCamMessage.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "NodeCamMessage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* RegisterNodeCamReqMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterNodeCamReqMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* RegisterNodeCamRepMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RegisterNodeCamRepMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* CamMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CamMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImageMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImageMsg_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_NodeCamMessage_2eproto() {
  protobuf_AddDesc_NodeCamMessage_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "NodeCamMessage.proto");
  GOOGLE_CHECK(file != NULL);
  RegisterNodeCamReqMsg_descriptor_ = file->message_type(0);
  static const int RegisterNodeCamReqMsg_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterNodeCamReqMsg, uri_),
  };
  RegisterNodeCamReqMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RegisterNodeCamReqMsg_descriptor_,
      RegisterNodeCamReqMsg::default_instance_,
      RegisterNodeCamReqMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterNodeCamReqMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterNodeCamReqMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RegisterNodeCamReqMsg));
  RegisterNodeCamRepMsg_descriptor_ = file->message_type(1);
  static const int RegisterNodeCamRepMsg_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterNodeCamRepMsg, time_step_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterNodeCamRepMsg, regsiter_flag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterNodeCamRepMsg, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterNodeCamRepMsg, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterNodeCamRepMsg, channels_),
  };
  RegisterNodeCamRepMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RegisterNodeCamRepMsg_descriptor_,
      RegisterNodeCamRepMsg::default_instance_,
      RegisterNodeCamRepMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterNodeCamRepMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RegisterNodeCamRepMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RegisterNodeCamRepMsg));
  CamMsg_descriptor_ = file->message_type(2);
  static const int CamMsg_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CamMsg, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CamMsg, time_step_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CamMsg, size_),
  };
  CamMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CamMsg_descriptor_,
      CamMsg::default_instance_,
      CamMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CamMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CamMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CamMsg));
  ImageMsg_descriptor_ = file->message_type(3);
  static const int ImageMsg_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMsg, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMsg, image_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMsg, image_height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMsg, image_width_),
  };
  ImageMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImageMsg_descriptor_,
      ImageMsg::default_instance_,
      ImageMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImageMsg));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_NodeCamMessage_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RegisterNodeCamReqMsg_descriptor_, &RegisterNodeCamReqMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RegisterNodeCamRepMsg_descriptor_, &RegisterNodeCamRepMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CamMsg_descriptor_, &CamMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImageMsg_descriptor_, &ImageMsg::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_NodeCamMessage_2eproto() {
  delete RegisterNodeCamReqMsg::default_instance_;
  delete RegisterNodeCamReqMsg_reflection_;
  delete RegisterNodeCamRepMsg::default_instance_;
  delete RegisterNodeCamRepMsg_reflection_;
  delete CamMsg::default_instance_;
  delete CamMsg_reflection_;
  delete ImageMsg::default_instance_;
  delete ImageMsg_reflection_;
}

void protobuf_AddDesc_NodeCamMessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\024NodeCamMessage.proto\"$\n\025RegisterNodeCa"
    "mReqMsg\022\013\n\003uri\030\001 \001(\014\"r\n\025RegisterNodeCamR"
    "epMsg\022\021\n\ttime_step\030\001 \001(\005\022\025\n\rregsiter_fla"
    "g\030\002 \001(\005\022\r\n\005width\030\003 \001(\005\022\016\n\006height\030\004 \001(\005\022\020"
    "\n\010channels\030\005 \001(\005\"C\n\006CamMsg\022\030\n\005image\030\001 \003("
    "\0132\t.ImageMsg\022\021\n\ttime_step\030\002 \002(\005\022\014\n\004size\030"
    "\003 \001(\005\"X\n\010ImageMsg\022\r\n\005image\030\001 \001(\014\022\022\n\nimag"
    "e_type\030\002 \001(\005\022\024\n\014image_height\030\003 \001(\005\022\023\n\013im"
    "age_width\030\004 \001(\005", 335);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "NodeCamMessage.proto", &protobuf_RegisterTypes);
  RegisterNodeCamReqMsg::default_instance_ = new RegisterNodeCamReqMsg();
  RegisterNodeCamRepMsg::default_instance_ = new RegisterNodeCamRepMsg();
  CamMsg::default_instance_ = new CamMsg();
  ImageMsg::default_instance_ = new ImageMsg();
  RegisterNodeCamReqMsg::default_instance_->InitAsDefaultInstance();
  RegisterNodeCamRepMsg::default_instance_->InitAsDefaultInstance();
  CamMsg::default_instance_->InitAsDefaultInstance();
  ImageMsg::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_NodeCamMessage_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_NodeCamMessage_2eproto {
  StaticDescriptorInitializer_NodeCamMessage_2eproto() {
    protobuf_AddDesc_NodeCamMessage_2eproto();
  }
} static_descriptor_initializer_NodeCamMessage_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int RegisterNodeCamReqMsg::kUriFieldNumber;
#endif  // !_MSC_VER

RegisterNodeCamReqMsg::RegisterNodeCamReqMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RegisterNodeCamReqMsg::InitAsDefaultInstance() {
}

RegisterNodeCamReqMsg::RegisterNodeCamReqMsg(const RegisterNodeCamReqMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterNodeCamReqMsg::SharedCtor() {
  _cached_size_ = 0;
  uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterNodeCamReqMsg::~RegisterNodeCamReqMsg() {
  SharedDtor();
}

void RegisterNodeCamReqMsg::SharedDtor() {
  if (uri_ != &::google::protobuf::internal::kEmptyString) {
    delete uri_;
  }
  if (this != default_instance_) {
  }
}

void RegisterNodeCamReqMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterNodeCamReqMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterNodeCamReqMsg_descriptor_;
}

const RegisterNodeCamReqMsg& RegisterNodeCamReqMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NodeCamMessage_2eproto();
  return *default_instance_;
}

RegisterNodeCamReqMsg* RegisterNodeCamReqMsg::default_instance_ = NULL;

RegisterNodeCamReqMsg* RegisterNodeCamReqMsg::New() const {
  return new RegisterNodeCamReqMsg;
}

void RegisterNodeCamReqMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_uri()) {
      if (uri_ != &::google::protobuf::internal::kEmptyString) {
        uri_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RegisterNodeCamReqMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes uri = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uri()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterNodeCamReqMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes uri = 1;
  if (has_uri()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->uri(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RegisterNodeCamReqMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes uri = 1;
  if (has_uri()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->uri(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RegisterNodeCamReqMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes uri = 1;
    if (has_uri()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uri());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterNodeCamReqMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RegisterNodeCamReqMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RegisterNodeCamReqMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegisterNodeCamReqMsg::MergeFrom(const RegisterNodeCamReqMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uri()) {
      set_uri(from.uri());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RegisterNodeCamReqMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterNodeCamReqMsg::CopyFrom(const RegisterNodeCamReqMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterNodeCamReqMsg::IsInitialized() const {

  return true;
}

void RegisterNodeCamReqMsg::Swap(RegisterNodeCamReqMsg* other) {
  if (other != this) {
    std::swap(uri_, other->uri_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RegisterNodeCamReqMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterNodeCamReqMsg_descriptor_;
  metadata.reflection = RegisterNodeCamReqMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RegisterNodeCamRepMsg::kTimeStepFieldNumber;
const int RegisterNodeCamRepMsg::kRegsiterFlagFieldNumber;
const int RegisterNodeCamRepMsg::kWidthFieldNumber;
const int RegisterNodeCamRepMsg::kHeightFieldNumber;
const int RegisterNodeCamRepMsg::kChannelsFieldNumber;
#endif  // !_MSC_VER

RegisterNodeCamRepMsg::RegisterNodeCamRepMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RegisterNodeCamRepMsg::InitAsDefaultInstance() {
}

RegisterNodeCamRepMsg::RegisterNodeCamRepMsg(const RegisterNodeCamRepMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RegisterNodeCamRepMsg::SharedCtor() {
  _cached_size_ = 0;
  time_step_ = 0;
  regsiter_flag_ = 0;
  width_ = 0;
  height_ = 0;
  channels_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterNodeCamRepMsg::~RegisterNodeCamRepMsg() {
  SharedDtor();
}

void RegisterNodeCamRepMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RegisterNodeCamRepMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RegisterNodeCamRepMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RegisterNodeCamRepMsg_descriptor_;
}

const RegisterNodeCamRepMsg& RegisterNodeCamRepMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NodeCamMessage_2eproto();
  return *default_instance_;
}

RegisterNodeCamRepMsg* RegisterNodeCamRepMsg::default_instance_ = NULL;

RegisterNodeCamRepMsg* RegisterNodeCamRepMsg::New() const {
  return new RegisterNodeCamRepMsg;
}

void RegisterNodeCamRepMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    time_step_ = 0;
    regsiter_flag_ = 0;
    width_ = 0;
    height_ = 0;
    channels_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RegisterNodeCamRepMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 time_step = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_step_)));
          set_has_time_step();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_regsiter_flag;
        break;
      }

      // optional int32 regsiter_flag = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_regsiter_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &regsiter_flag_)));
          set_has_regsiter_flag();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_width;
        break;
      }

      // optional int32 width = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_height;
        break;
      }

      // optional int32 height = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_channels;
        break;
      }

      // optional int32 channels = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_channels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channels_)));
          set_has_channels();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RegisterNodeCamRepMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 time_step = 1;
  if (has_time_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->time_step(), output);
  }

  // optional int32 regsiter_flag = 2;
  if (has_regsiter_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->regsiter_flag(), output);
  }

  // optional int32 width = 3;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->width(), output);
  }

  // optional int32 height = 4;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->height(), output);
  }

  // optional int32 channels = 5;
  if (has_channels()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->channels(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RegisterNodeCamRepMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 time_step = 1;
  if (has_time_step()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->time_step(), target);
  }

  // optional int32 regsiter_flag = 2;
  if (has_regsiter_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->regsiter_flag(), target);
  }

  // optional int32 width = 3;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->width(), target);
  }

  // optional int32 height = 4;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->height(), target);
  }

  // optional int32 channels = 5;
  if (has_channels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->channels(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RegisterNodeCamRepMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 time_step = 1;
    if (has_time_step()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time_step());
    }

    // optional int32 regsiter_flag = 2;
    if (has_regsiter_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->regsiter_flag());
    }

    // optional int32 width = 3;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }

    // optional int32 height = 4;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }

    // optional int32 channels = 5;
    if (has_channels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channels());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterNodeCamRepMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RegisterNodeCamRepMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RegisterNodeCamRepMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RegisterNodeCamRepMsg::MergeFrom(const RegisterNodeCamRepMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_step()) {
      set_time_step(from.time_step());
    }
    if (from.has_regsiter_flag()) {
      set_regsiter_flag(from.regsiter_flag());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_channels()) {
      set_channels(from.channels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RegisterNodeCamRepMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RegisterNodeCamRepMsg::CopyFrom(const RegisterNodeCamRepMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterNodeCamRepMsg::IsInitialized() const {

  return true;
}

void RegisterNodeCamRepMsg::Swap(RegisterNodeCamRepMsg* other) {
  if (other != this) {
    std::swap(time_step_, other->time_step_);
    std::swap(regsiter_flag_, other->regsiter_flag_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(channels_, other->channels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RegisterNodeCamRepMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RegisterNodeCamRepMsg_descriptor_;
  metadata.reflection = RegisterNodeCamRepMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CamMsg::kImageFieldNumber;
const int CamMsg::kTimeStepFieldNumber;
const int CamMsg::kSizeFieldNumber;
#endif  // !_MSC_VER

CamMsg::CamMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CamMsg::InitAsDefaultInstance() {
}

CamMsg::CamMsg(const CamMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CamMsg::SharedCtor() {
  _cached_size_ = 0;
  time_step_ = 0;
  size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CamMsg::~CamMsg() {
  SharedDtor();
}

void CamMsg::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CamMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CamMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CamMsg_descriptor_;
}

const CamMsg& CamMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NodeCamMessage_2eproto();
  return *default_instance_;
}

CamMsg* CamMsg::default_instance_ = NULL;

CamMsg* CamMsg::New() const {
  return new CamMsg;
}

void CamMsg::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    time_step_ = 0;
    size_ = 0;
  }
  image_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CamMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ImageMsg image = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_image()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_image;
        if (input->ExpectTag(16)) goto parse_time_step;
        break;
      }

      // required int32 time_step = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_time_step:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &time_step_)));
          set_has_time_step();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_size;
        break;
      }

      // optional int32 size = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CamMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .ImageMsg image = 1;
  for (int i = 0; i < this->image_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->image(i), output);
  }

  // required int32 time_step = 2;
  if (has_time_step()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->time_step(), output);
  }

  // optional int32 size = 3;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CamMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .ImageMsg image = 1;
  for (int i = 0; i < this->image_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->image(i), target);
  }

  // required int32 time_step = 2;
  if (has_time_step()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->time_step(), target);
  }

  // optional int32 size = 3;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CamMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required int32 time_step = 2;
    if (has_time_step()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->time_step());
    }

    // optional int32 size = 3;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->size());
    }

  }
  // repeated .ImageMsg image = 1;
  total_size += 1 * this->image_size();
  for (int i = 0; i < this->image_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->image(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CamMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CamMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CamMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CamMsg::MergeFrom(const CamMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  image_.MergeFrom(from.image_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_time_step()) {
      set_time_step(from.time_step());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CamMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CamMsg::CopyFrom(const CamMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CamMsg::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void CamMsg::Swap(CamMsg* other) {
  if (other != this) {
    image_.Swap(&other->image_);
    std::swap(time_step_, other->time_step_);
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CamMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CamMsg_descriptor_;
  metadata.reflection = CamMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ImageMsg::kImageFieldNumber;
const int ImageMsg::kImageTypeFieldNumber;
const int ImageMsg::kImageHeightFieldNumber;
const int ImageMsg::kImageWidthFieldNumber;
#endif  // !_MSC_VER

ImageMsg::ImageMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ImageMsg::InitAsDefaultInstance() {
}

ImageMsg::ImageMsg(const ImageMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ImageMsg::SharedCtor() {
  _cached_size_ = 0;
  image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  image_type_ = 0;
  image_height_ = 0;
  image_width_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImageMsg::~ImageMsg() {
  SharedDtor();
}

void ImageMsg::SharedDtor() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (this != default_instance_) {
  }
}

void ImageMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImageMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImageMsg_descriptor_;
}

const ImageMsg& ImageMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_NodeCamMessage_2eproto();
  return *default_instance_;
}

ImageMsg* ImageMsg::default_instance_ = NULL;

ImageMsg* ImageMsg::New() const {
  return new ImageMsg;
}

void ImageMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_image()) {
      if (image_ != &::google::protobuf::internal::kEmptyString) {
        image_->clear();
      }
    }
    image_type_ = 0;
    image_height_ = 0;
    image_width_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImageMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes image = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_image()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_image_type;
        break;
      }

      // optional int32 image_type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_image_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &image_type_)));
          set_has_image_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_image_height;
        break;
      }

      // optional int32 image_height = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_image_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &image_height_)));
          set_has_image_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_image_width;
        break;
      }

      // optional int32 image_width = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_image_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &image_width_)));
          set_has_image_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ImageMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes image = 1;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->image(), output);
  }

  // optional int32 image_type = 2;
  if (has_image_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->image_type(), output);
  }

  // optional int32 image_height = 3;
  if (has_image_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->image_height(), output);
  }

  // optional int32 image_width = 4;
  if (has_image_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->image_width(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ImageMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes image = 1;
  if (has_image()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->image(), target);
  }

  // optional int32 image_type = 2;
  if (has_image_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->image_type(), target);
  }

  // optional int32 image_height = 3;
  if (has_image_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->image_height(), target);
  }

  // optional int32 image_width = 4;
  if (has_image_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->image_width(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ImageMsg::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes image = 1;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->image());
    }

    // optional int32 image_type = 2;
    if (has_image_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->image_type());
    }

    // optional int32 image_height = 3;
    if (has_image_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->image_height());
    }

    // optional int32 image_width = 4;
    if (has_image_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->image_width());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImageMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImageMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImageMsg::MergeFrom(const ImageMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_image()) {
      set_image(from.image());
    }
    if (from.has_image_type()) {
      set_image_type(from.image_type());
    }
    if (from.has_image_height()) {
      set_image_height(from.image_height());
    }
    if (from.has_image_width()) {
      set_image_width(from.image_width());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImageMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImageMsg::CopyFrom(const ImageMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageMsg::IsInitialized() const {

  return true;
}

void ImageMsg::Swap(ImageMsg* other) {
  if (other != this) {
    std::swap(image_, other->image_);
    std::swap(image_type_, other->image_type_);
    std::swap(image_height_, other->image_height_);
    std::swap(image_width_, other->image_width_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImageMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImageMsg_descriptor_;
  metadata.reflection = ImageMsg_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
