// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SlamServer.proto

#ifndef PROTOBUF_SlamServer_2eproto__INCLUDED
#define PROTOBUF_SlamServer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "rslam.pb.h"
#include "frontend.pb.h"
#include "template.pb.h"
#include "dbow.pb.h"
#include "Camera.pb.h"
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SlamServer_2eproto();
void protobuf_AssignDesc_SlamServer_2eproto();
void protobuf_ShutdownFile_SlamServer_2eproto();

class PlaceMapMsg;
class ServerUploadRequest;
class ServerUploadResponse;
class ServerQueryRequest;
class ServerQueryResponse;
class ServerDownloadRequest;
class ServerDownloadResponse;

enum PlaceMatcherType {
  DBOW = 1,
  TEMPLATE = 2,
  MULTI_DBOW = 3
};
bool PlaceMatcherType_IsValid(int value);
const PlaceMatcherType PlaceMatcherType_MIN = DBOW;
const PlaceMatcherType PlaceMatcherType_MAX = MULTI_DBOW;
const int PlaceMatcherType_ARRAYSIZE = PlaceMatcherType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlaceMatcherType_descriptor();
inline const ::std::string& PlaceMatcherType_Name(PlaceMatcherType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlaceMatcherType_descriptor(), value);
}
inline bool PlaceMatcherType_Parse(
    const ::std::string& name, PlaceMatcherType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlaceMatcherType>(
    PlaceMatcherType_descriptor(), name, value);
}
// ===================================================================

class PlaceMapMsg : public ::google::protobuf::Message {
 public:
  PlaceMapMsg();
  virtual ~PlaceMapMsg();

  PlaceMapMsg(const PlaceMapMsg& from);

  inline PlaceMapMsg& operator=(const PlaceMapMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlaceMapMsg& default_instance();

  void Swap(PlaceMapMsg* other);

  // implements Message ----------------------------------------------

  PlaceMapMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlaceMapMsg& from);
  void MergeFrom(const PlaceMapMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.SlamMapMsg map = 1;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 1;
  inline const ::pb::SlamMapMsg& map() const;
  inline ::pb::SlamMapMsg* mutable_map();
  inline ::pb::SlamMapMsg* release_map();
  inline void set_allocated_map(::pb::SlamMapMsg* map);

  // repeated .pb.ReferenceFrameIdMsg leaf = 2;
  inline int leaf_size() const;
  inline void clear_leaf();
  static const int kLeafFieldNumber = 2;
  inline const ::pb::ReferenceFrameIdMsg& leaf(int index) const;
  inline ::pb::ReferenceFrameIdMsg* mutable_leaf(int index);
  inline ::pb::ReferenceFrameIdMsg* add_leaf();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::ReferenceFrameIdMsg >&
      leaf() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::ReferenceFrameIdMsg >*
      mutable_leaf();

  // optional .pb.PlaceMatcherType place_type = 3;
  inline bool has_place_type() const;
  inline void clear_place_type();
  static const int kPlaceTypeFieldNumber = 3;
  inline ::pb::PlaceMatcherType place_type() const;
  inline void set_place_type(::pb::PlaceMatcherType value);

  // repeated .pb.TemplateMsg templates = 4;
  inline int templates_size() const;
  inline void clear_templates();
  static const int kTemplatesFieldNumber = 4;
  inline const ::pb::TemplateMsg& templates(int index) const;
  inline ::pb::TemplateMsg* mutable_templates(int index);
  inline ::pb::TemplateMsg* add_templates();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::TemplateMsg >&
      templates() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::TemplateMsg >*
      mutable_templates();

  // repeated .pb.DBoWPlaceMsg dbow_places = 5;
  inline int dbow_places_size() const;
  inline void clear_dbow_places();
  static const int kDbowPlacesFieldNumber = 5;
  inline const ::pb::DBoWPlaceMsg& dbow_places(int index) const;
  inline ::pb::DBoWPlaceMsg* mutable_dbow_places(int index);
  inline ::pb::DBoWPlaceMsg* add_dbow_places();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::DBoWPlaceMsg >&
      dbow_places() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::DBoWPlaceMsg >*
      mutable_dbow_places();

  // @@protoc_insertion_point(class_scope:pb.PlaceMapMsg)
 private:
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_place_type();
  inline void clear_has_place_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::SlamMapMsg* map_;
  ::google::protobuf::RepeatedPtrField< ::pb::ReferenceFrameIdMsg > leaf_;
  ::google::protobuf::RepeatedPtrField< ::pb::TemplateMsg > templates_;
  ::google::protobuf::RepeatedPtrField< ::pb::DBoWPlaceMsg > dbow_places_;
  int place_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_SlamServer_2eproto();
  friend void protobuf_AssignDesc_SlamServer_2eproto();
  friend void protobuf_ShutdownFile_SlamServer_2eproto();

  void InitAsDefaultInstance();
  static PlaceMapMsg* default_instance_;
};
// -------------------------------------------------------------------

class ServerUploadRequest : public ::google::protobuf::Message {
 public:
  ServerUploadRequest();
  virtual ~ServerUploadRequest();

  ServerUploadRequest(const ServerUploadRequest& from);

  inline ServerUploadRequest& operator=(const ServerUploadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerUploadRequest& default_instance();

  void Swap(ServerUploadRequest* other);

  // implements Message ----------------------------------------------

  ServerUploadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerUploadRequest& from);
  void MergeFrom(const ServerUploadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.PlaceMapMsg map = 1;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 1;
  inline const ::pb::PlaceMapMsg& map() const;
  inline ::pb::PlaceMapMsg* mutable_map();
  inline ::pb::PlaceMapMsg* release_map();
  inline void set_allocated_map(::pb::PlaceMapMsg* map);

  // @@protoc_insertion_point(class_scope:pb.ServerUploadRequest)
 private:
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::PlaceMapMsg* map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SlamServer_2eproto();
  friend void protobuf_AssignDesc_SlamServer_2eproto();
  friend void protobuf_ShutdownFile_SlamServer_2eproto();

  void InitAsDefaultInstance();
  static ServerUploadRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServerUploadResponse : public ::google::protobuf::Message {
 public:
  ServerUploadResponse();
  virtual ~ServerUploadResponse();

  ServerUploadResponse(const ServerUploadResponse& from);

  inline ServerUploadResponse& operator=(const ServerUploadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerUploadResponse& default_instance();

  void Swap(ServerUploadResponse* other);

  // implements Message ----------------------------------------------

  ServerUploadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerUploadResponse& from);
  void MergeFrom(const ServerUploadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // @@protoc_insertion_point(class_scope:pb.ServerUploadResponse)
 private:
  inline void set_has_success();
  inline void clear_has_success();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool success_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SlamServer_2eproto();
  friend void protobuf_AssignDesc_SlamServer_2eproto();
  friend void protobuf_ShutdownFile_SlamServer_2eproto();

  void InitAsDefaultInstance();
  static ServerUploadResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServerQueryRequest : public ::google::protobuf::Message {
 public:
  ServerQueryRequest();
  virtual ~ServerQueryRequest();

  ServerQueryRequest(const ServerQueryRequest& from);

  inline ServerQueryRequest& operator=(const ServerQueryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerQueryRequest& default_instance();

  void Swap(ServerQueryRequest* other);

  // implements Message ----------------------------------------------

  ServerQueryRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerQueryRequest& from);
  void MergeFrom(const ServerQueryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.CameraMsg images = 1;
  inline bool has_images() const;
  inline void clear_images();
  static const int kImagesFieldNumber = 1;
  inline const ::pb::CameraMsg& images() const;
  inline ::pb::CameraMsg* mutable_images();
  inline ::pb::CameraMsg* release_images();
  inline void set_allocated_images(::pb::CameraMsg* images);

  // optional .pb.CameraRigMsg rig = 2;
  inline bool has_rig() const;
  inline void clear_rig();
  static const int kRigFieldNumber = 2;
  inline const ::pb::CameraRigMsg& rig() const;
  inline ::pb::CameraRigMsg* mutable_rig();
  inline ::pb::CameraRigMsg* release_rig();
  inline void set_allocated_rig(::pb::CameraRigMsg* rig);

  // optional .pb.ReferenceFrameMsg frame = 3;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 3;
  inline const ::pb::ReferenceFrameMsg& frame() const;
  inline ::pb::ReferenceFrameMsg* mutable_frame();
  inline ::pb::ReferenceFrameMsg* release_frame();
  inline void set_allocated_frame(::pb::ReferenceFrameMsg* frame);

  // @@protoc_insertion_point(class_scope:pb.ServerQueryRequest)
 private:
  inline void set_has_images();
  inline void clear_has_images();
  inline void set_has_rig();
  inline void clear_has_rig();
  inline void set_has_frame();
  inline void clear_has_frame();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::CameraMsg* images_;
  ::pb::CameraRigMsg* rig_;
  ::pb::ReferenceFrameMsg* frame_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SlamServer_2eproto();
  friend void protobuf_AssignDesc_SlamServer_2eproto();
  friend void protobuf_ShutdownFile_SlamServer_2eproto();

  void InitAsDefaultInstance();
  static ServerQueryRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServerQueryResponse : public ::google::protobuf::Message {
 public:
  ServerQueryResponse();
  virtual ~ServerQueryResponse();

  ServerQueryResponse(const ServerQueryResponse& from);

  inline ServerQueryResponse& operator=(const ServerQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerQueryResponse& default_instance();

  void Swap(ServerQueryResponse* other);

  // implements Message ----------------------------------------------

  ServerQueryResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerQueryResponse& from);
  void MergeFrom(const ServerQueryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // optional .pb.TransformEdgeMsg edge = 2;
  inline bool has_edge() const;
  inline void clear_edge();
  static const int kEdgeFieldNumber = 2;
  inline const ::pb::TransformEdgeMsg& edge() const;
  inline ::pb::TransformEdgeMsg* mutable_edge();
  inline ::pb::TransformEdgeMsg* release_edge();
  inline void set_allocated_edge(::pb::TransformEdgeMsg* edge);

  // repeated .pb.MultiViewMeasurementMsg measurements = 3;
  inline int measurements_size() const;
  inline void clear_measurements();
  static const int kMeasurementsFieldNumber = 3;
  inline const ::pb::MultiViewMeasurementMsg& measurements(int index) const;
  inline ::pb::MultiViewMeasurementMsg* mutable_measurements(int index);
  inline ::pb::MultiViewMeasurementMsg* add_measurements();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::MultiViewMeasurementMsg >&
      measurements() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::MultiViewMeasurementMsg >*
      mutable_measurements();

  // @@protoc_insertion_point(class_scope:pb.ServerQueryResponse)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_edge();
  inline void clear_has_edge();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::TransformEdgeMsg* edge_;
  ::google::protobuf::RepeatedPtrField< ::pb::MultiViewMeasurementMsg > measurements_;
  bool success_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SlamServer_2eproto();
  friend void protobuf_AssignDesc_SlamServer_2eproto();
  friend void protobuf_ShutdownFile_SlamServer_2eproto();

  void InitAsDefaultInstance();
  static ServerQueryResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServerDownloadRequest : public ::google::protobuf::Message {
 public:
  ServerDownloadRequest();
  virtual ~ServerDownloadRequest();

  ServerDownloadRequest(const ServerDownloadRequest& from);

  inline ServerDownloadRequest& operator=(const ServerDownloadRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerDownloadRequest& default_instance();

  void Swap(ServerDownloadRequest* other);

  // implements Message ----------------------------------------------

  ServerDownloadRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerDownloadRequest& from);
  void MergeFrom(const ServerDownloadRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pb.ReferenceFrameIdMsg frame_id = 1;
  inline bool has_frame_id() const;
  inline void clear_frame_id();
  static const int kFrameIdFieldNumber = 1;
  inline const ::pb::ReferenceFrameIdMsg& frame_id() const;
  inline ::pb::ReferenceFrameIdMsg* mutable_frame_id();
  inline ::pb::ReferenceFrameIdMsg* release_frame_id();
  inline void set_allocated_frame_id(::pb::ReferenceFrameIdMsg* frame_id);

  // optional uint64 depth = 2;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 2;
  inline ::google::protobuf::uint64 depth() const;
  inline void set_depth(::google::protobuf::uint64 value);

  // optional double last_download_time = 3;
  inline bool has_last_download_time() const;
  inline void clear_last_download_time();
  static const int kLastDownloadTimeFieldNumber = 3;
  inline double last_download_time() const;
  inline void set_last_download_time(double value);

  // optional .pb.SessionIdMsg excluding_map = 4;
  inline bool has_excluding_map() const;
  inline void clear_excluding_map();
  static const int kExcludingMapFieldNumber = 4;
  inline const ::pb::SessionIdMsg& excluding_map() const;
  inline ::pb::SessionIdMsg* mutable_excluding_map();
  inline ::pb::SessionIdMsg* release_excluding_map();
  inline void set_allocated_excluding_map(::pb::SessionIdMsg* excluding_map);

  // @@protoc_insertion_point(class_scope:pb.ServerDownloadRequest)
 private:
  inline void set_has_frame_id();
  inline void clear_has_frame_id();
  inline void set_has_depth();
  inline void clear_has_depth();
  inline void set_has_last_download_time();
  inline void clear_has_last_download_time();
  inline void set_has_excluding_map();
  inline void clear_has_excluding_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pb::ReferenceFrameIdMsg* frame_id_;
  ::google::protobuf::uint64 depth_;
  double last_download_time_;
  ::pb::SessionIdMsg* excluding_map_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_SlamServer_2eproto();
  friend void protobuf_AssignDesc_SlamServer_2eproto();
  friend void protobuf_ShutdownFile_SlamServer_2eproto();

  void InitAsDefaultInstance();
  static ServerDownloadRequest* default_instance_;
};
// -------------------------------------------------------------------

class ServerDownloadResponse : public ::google::protobuf::Message {
 public:
  ServerDownloadResponse();
  virtual ~ServerDownloadResponse();

  ServerDownloadResponse(const ServerDownloadResponse& from);

  inline ServerDownloadResponse& operator=(const ServerDownloadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerDownloadResponse& default_instance();

  void Swap(ServerDownloadResponse* other);

  // implements Message ----------------------------------------------

  ServerDownloadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerDownloadResponse& from);
  void MergeFrom(const ServerDownloadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // optional double timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline double timestamp() const;
  inline void set_timestamp(double value);

  // optional .pb.PlaceMapMsg map = 3;
  inline bool has_map() const;
  inline void clear_map();
  static const int kMapFieldNumber = 3;
  inline const ::pb::PlaceMapMsg& map() const;
  inline ::pb::PlaceMapMsg* mutable_map();
  inline ::pb::PlaceMapMsg* release_map();
  inline void set_allocated_map(::pb::PlaceMapMsg* map);

  // @@protoc_insertion_point(class_scope:pb.ServerDownloadResponse)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_map();
  inline void clear_has_map();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double timestamp_;
  ::pb::PlaceMapMsg* map_;
  bool success_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SlamServer_2eproto();
  friend void protobuf_AssignDesc_SlamServer_2eproto();
  friend void protobuf_ShutdownFile_SlamServer_2eproto();

  void InitAsDefaultInstance();
  static ServerDownloadResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// PlaceMapMsg

// optional .pb.SlamMapMsg map = 1;
inline bool PlaceMapMsg::has_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlaceMapMsg::set_has_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlaceMapMsg::clear_has_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlaceMapMsg::clear_map() {
  if (map_ != NULL) map_->::pb::SlamMapMsg::Clear();
  clear_has_map();
}
inline const ::pb::SlamMapMsg& PlaceMapMsg::map() const {
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::pb::SlamMapMsg* PlaceMapMsg::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::pb::SlamMapMsg;
  return map_;
}
inline ::pb::SlamMapMsg* PlaceMapMsg::release_map() {
  clear_has_map();
  ::pb::SlamMapMsg* temp = map_;
  map_ = NULL;
  return temp;
}
inline void PlaceMapMsg::set_allocated_map(::pb::SlamMapMsg* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
}

// repeated .pb.ReferenceFrameIdMsg leaf = 2;
inline int PlaceMapMsg::leaf_size() const {
  return leaf_.size();
}
inline void PlaceMapMsg::clear_leaf() {
  leaf_.Clear();
}
inline const ::pb::ReferenceFrameIdMsg& PlaceMapMsg::leaf(int index) const {
  return leaf_.Get(index);
}
inline ::pb::ReferenceFrameIdMsg* PlaceMapMsg::mutable_leaf(int index) {
  return leaf_.Mutable(index);
}
inline ::pb::ReferenceFrameIdMsg* PlaceMapMsg::add_leaf() {
  return leaf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::ReferenceFrameIdMsg >&
PlaceMapMsg::leaf() const {
  return leaf_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::ReferenceFrameIdMsg >*
PlaceMapMsg::mutable_leaf() {
  return &leaf_;
}

// optional .pb.PlaceMatcherType place_type = 3;
inline bool PlaceMapMsg::has_place_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlaceMapMsg::set_has_place_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlaceMapMsg::clear_has_place_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlaceMapMsg::clear_place_type() {
  place_type_ = 1;
  clear_has_place_type();
}
inline ::pb::PlaceMatcherType PlaceMapMsg::place_type() const {
  return static_cast< ::pb::PlaceMatcherType >(place_type_);
}
inline void PlaceMapMsg::set_place_type(::pb::PlaceMatcherType value) {
  assert(::pb::PlaceMatcherType_IsValid(value));
  set_has_place_type();
  place_type_ = value;
}

// repeated .pb.TemplateMsg templates = 4;
inline int PlaceMapMsg::templates_size() const {
  return templates_.size();
}
inline void PlaceMapMsg::clear_templates() {
  templates_.Clear();
}
inline const ::pb::TemplateMsg& PlaceMapMsg::templates(int index) const {
  return templates_.Get(index);
}
inline ::pb::TemplateMsg* PlaceMapMsg::mutable_templates(int index) {
  return templates_.Mutable(index);
}
inline ::pb::TemplateMsg* PlaceMapMsg::add_templates() {
  return templates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::TemplateMsg >&
PlaceMapMsg::templates() const {
  return templates_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::TemplateMsg >*
PlaceMapMsg::mutable_templates() {
  return &templates_;
}

// repeated .pb.DBoWPlaceMsg dbow_places = 5;
inline int PlaceMapMsg::dbow_places_size() const {
  return dbow_places_.size();
}
inline void PlaceMapMsg::clear_dbow_places() {
  dbow_places_.Clear();
}
inline const ::pb::DBoWPlaceMsg& PlaceMapMsg::dbow_places(int index) const {
  return dbow_places_.Get(index);
}
inline ::pb::DBoWPlaceMsg* PlaceMapMsg::mutable_dbow_places(int index) {
  return dbow_places_.Mutable(index);
}
inline ::pb::DBoWPlaceMsg* PlaceMapMsg::add_dbow_places() {
  return dbow_places_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::DBoWPlaceMsg >&
PlaceMapMsg::dbow_places() const {
  return dbow_places_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::DBoWPlaceMsg >*
PlaceMapMsg::mutable_dbow_places() {
  return &dbow_places_;
}

// -------------------------------------------------------------------

// ServerUploadRequest

// optional .pb.PlaceMapMsg map = 1;
inline bool ServerUploadRequest::has_map() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerUploadRequest::set_has_map() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerUploadRequest::clear_has_map() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerUploadRequest::clear_map() {
  if (map_ != NULL) map_->::pb::PlaceMapMsg::Clear();
  clear_has_map();
}
inline const ::pb::PlaceMapMsg& ServerUploadRequest::map() const {
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::pb::PlaceMapMsg* ServerUploadRequest::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::pb::PlaceMapMsg;
  return map_;
}
inline ::pb::PlaceMapMsg* ServerUploadRequest::release_map() {
  clear_has_map();
  ::pb::PlaceMapMsg* temp = map_;
  map_ = NULL;
  return temp;
}
inline void ServerUploadRequest::set_allocated_map(::pb::PlaceMapMsg* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
}

// -------------------------------------------------------------------

// ServerUploadResponse

// optional bool success = 1;
inline bool ServerUploadResponse::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerUploadResponse::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerUploadResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerUploadResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ServerUploadResponse::success() const {
  return success_;
}
inline void ServerUploadResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// -------------------------------------------------------------------

// ServerQueryRequest

// optional .pb.CameraMsg images = 1;
inline bool ServerQueryRequest::has_images() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerQueryRequest::set_has_images() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerQueryRequest::clear_has_images() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerQueryRequest::clear_images() {
  if (images_ != NULL) images_->::pb::CameraMsg::Clear();
  clear_has_images();
}
inline const ::pb::CameraMsg& ServerQueryRequest::images() const {
  return images_ != NULL ? *images_ : *default_instance_->images_;
}
inline ::pb::CameraMsg* ServerQueryRequest::mutable_images() {
  set_has_images();
  if (images_ == NULL) images_ = new ::pb::CameraMsg;
  return images_;
}
inline ::pb::CameraMsg* ServerQueryRequest::release_images() {
  clear_has_images();
  ::pb::CameraMsg* temp = images_;
  images_ = NULL;
  return temp;
}
inline void ServerQueryRequest::set_allocated_images(::pb::CameraMsg* images) {
  delete images_;
  images_ = images;
  if (images) {
    set_has_images();
  } else {
    clear_has_images();
  }
}

// optional .pb.CameraRigMsg rig = 2;
inline bool ServerQueryRequest::has_rig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerQueryRequest::set_has_rig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerQueryRequest::clear_has_rig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerQueryRequest::clear_rig() {
  if (rig_ != NULL) rig_->::pb::CameraRigMsg::Clear();
  clear_has_rig();
}
inline const ::pb::CameraRigMsg& ServerQueryRequest::rig() const {
  return rig_ != NULL ? *rig_ : *default_instance_->rig_;
}
inline ::pb::CameraRigMsg* ServerQueryRequest::mutable_rig() {
  set_has_rig();
  if (rig_ == NULL) rig_ = new ::pb::CameraRigMsg;
  return rig_;
}
inline ::pb::CameraRigMsg* ServerQueryRequest::release_rig() {
  clear_has_rig();
  ::pb::CameraRigMsg* temp = rig_;
  rig_ = NULL;
  return temp;
}
inline void ServerQueryRequest::set_allocated_rig(::pb::CameraRigMsg* rig) {
  delete rig_;
  rig_ = rig;
  if (rig) {
    set_has_rig();
  } else {
    clear_has_rig();
  }
}

// optional .pb.ReferenceFrameMsg frame = 3;
inline bool ServerQueryRequest::has_frame() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerQueryRequest::set_has_frame() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerQueryRequest::clear_has_frame() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerQueryRequest::clear_frame() {
  if (frame_ != NULL) frame_->::pb::ReferenceFrameMsg::Clear();
  clear_has_frame();
}
inline const ::pb::ReferenceFrameMsg& ServerQueryRequest::frame() const {
  return frame_ != NULL ? *frame_ : *default_instance_->frame_;
}
inline ::pb::ReferenceFrameMsg* ServerQueryRequest::mutable_frame() {
  set_has_frame();
  if (frame_ == NULL) frame_ = new ::pb::ReferenceFrameMsg;
  return frame_;
}
inline ::pb::ReferenceFrameMsg* ServerQueryRequest::release_frame() {
  clear_has_frame();
  ::pb::ReferenceFrameMsg* temp = frame_;
  frame_ = NULL;
  return temp;
}
inline void ServerQueryRequest::set_allocated_frame(::pb::ReferenceFrameMsg* frame) {
  delete frame_;
  frame_ = frame;
  if (frame) {
    set_has_frame();
  } else {
    clear_has_frame();
  }
}

// -------------------------------------------------------------------

// ServerQueryResponse

// optional bool success = 1;
inline bool ServerQueryResponse::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerQueryResponse::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerQueryResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerQueryResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ServerQueryResponse::success() const {
  return success_;
}
inline void ServerQueryResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional .pb.TransformEdgeMsg edge = 2;
inline bool ServerQueryResponse::has_edge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerQueryResponse::set_has_edge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerQueryResponse::clear_has_edge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerQueryResponse::clear_edge() {
  if (edge_ != NULL) edge_->::pb::TransformEdgeMsg::Clear();
  clear_has_edge();
}
inline const ::pb::TransformEdgeMsg& ServerQueryResponse::edge() const {
  return edge_ != NULL ? *edge_ : *default_instance_->edge_;
}
inline ::pb::TransformEdgeMsg* ServerQueryResponse::mutable_edge() {
  set_has_edge();
  if (edge_ == NULL) edge_ = new ::pb::TransformEdgeMsg;
  return edge_;
}
inline ::pb::TransformEdgeMsg* ServerQueryResponse::release_edge() {
  clear_has_edge();
  ::pb::TransformEdgeMsg* temp = edge_;
  edge_ = NULL;
  return temp;
}
inline void ServerQueryResponse::set_allocated_edge(::pb::TransformEdgeMsg* edge) {
  delete edge_;
  edge_ = edge;
  if (edge) {
    set_has_edge();
  } else {
    clear_has_edge();
  }
}

// repeated .pb.MultiViewMeasurementMsg measurements = 3;
inline int ServerQueryResponse::measurements_size() const {
  return measurements_.size();
}
inline void ServerQueryResponse::clear_measurements() {
  measurements_.Clear();
}
inline const ::pb::MultiViewMeasurementMsg& ServerQueryResponse::measurements(int index) const {
  return measurements_.Get(index);
}
inline ::pb::MultiViewMeasurementMsg* ServerQueryResponse::mutable_measurements(int index) {
  return measurements_.Mutable(index);
}
inline ::pb::MultiViewMeasurementMsg* ServerQueryResponse::add_measurements() {
  return measurements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::MultiViewMeasurementMsg >&
ServerQueryResponse::measurements() const {
  return measurements_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::MultiViewMeasurementMsg >*
ServerQueryResponse::mutable_measurements() {
  return &measurements_;
}

// -------------------------------------------------------------------

// ServerDownloadRequest

// optional .pb.ReferenceFrameIdMsg frame_id = 1;
inline bool ServerDownloadRequest::has_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerDownloadRequest::set_has_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerDownloadRequest::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerDownloadRequest::clear_frame_id() {
  if (frame_id_ != NULL) frame_id_->::pb::ReferenceFrameIdMsg::Clear();
  clear_has_frame_id();
}
inline const ::pb::ReferenceFrameIdMsg& ServerDownloadRequest::frame_id() const {
  return frame_id_ != NULL ? *frame_id_ : *default_instance_->frame_id_;
}
inline ::pb::ReferenceFrameIdMsg* ServerDownloadRequest::mutable_frame_id() {
  set_has_frame_id();
  if (frame_id_ == NULL) frame_id_ = new ::pb::ReferenceFrameIdMsg;
  return frame_id_;
}
inline ::pb::ReferenceFrameIdMsg* ServerDownloadRequest::release_frame_id() {
  clear_has_frame_id();
  ::pb::ReferenceFrameIdMsg* temp = frame_id_;
  frame_id_ = NULL;
  return temp;
}
inline void ServerDownloadRequest::set_allocated_frame_id(::pb::ReferenceFrameIdMsg* frame_id) {
  delete frame_id_;
  frame_id_ = frame_id;
  if (frame_id) {
    set_has_frame_id();
  } else {
    clear_has_frame_id();
  }
}

// optional uint64 depth = 2;
inline bool ServerDownloadRequest::has_depth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerDownloadRequest::set_has_depth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerDownloadRequest::clear_has_depth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerDownloadRequest::clear_depth() {
  depth_ = GOOGLE_ULONGLONG(0);
  clear_has_depth();
}
inline ::google::protobuf::uint64 ServerDownloadRequest::depth() const {
  return depth_;
}
inline void ServerDownloadRequest::set_depth(::google::protobuf::uint64 value) {
  set_has_depth();
  depth_ = value;
}

// optional double last_download_time = 3;
inline bool ServerDownloadRequest::has_last_download_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerDownloadRequest::set_has_last_download_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerDownloadRequest::clear_has_last_download_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerDownloadRequest::clear_last_download_time() {
  last_download_time_ = 0;
  clear_has_last_download_time();
}
inline double ServerDownloadRequest::last_download_time() const {
  return last_download_time_;
}
inline void ServerDownloadRequest::set_last_download_time(double value) {
  set_has_last_download_time();
  last_download_time_ = value;
}

// optional .pb.SessionIdMsg excluding_map = 4;
inline bool ServerDownloadRequest::has_excluding_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerDownloadRequest::set_has_excluding_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerDownloadRequest::clear_has_excluding_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerDownloadRequest::clear_excluding_map() {
  if (excluding_map_ != NULL) excluding_map_->::pb::SessionIdMsg::Clear();
  clear_has_excluding_map();
}
inline const ::pb::SessionIdMsg& ServerDownloadRequest::excluding_map() const {
  return excluding_map_ != NULL ? *excluding_map_ : *default_instance_->excluding_map_;
}
inline ::pb::SessionIdMsg* ServerDownloadRequest::mutable_excluding_map() {
  set_has_excluding_map();
  if (excluding_map_ == NULL) excluding_map_ = new ::pb::SessionIdMsg;
  return excluding_map_;
}
inline ::pb::SessionIdMsg* ServerDownloadRequest::release_excluding_map() {
  clear_has_excluding_map();
  ::pb::SessionIdMsg* temp = excluding_map_;
  excluding_map_ = NULL;
  return temp;
}
inline void ServerDownloadRequest::set_allocated_excluding_map(::pb::SessionIdMsg* excluding_map) {
  delete excluding_map_;
  excluding_map_ = excluding_map;
  if (excluding_map) {
    set_has_excluding_map();
  } else {
    clear_has_excluding_map();
  }
}

// -------------------------------------------------------------------

// ServerDownloadResponse

// optional bool success = 1;
inline bool ServerDownloadResponse::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerDownloadResponse::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerDownloadResponse::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerDownloadResponse::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ServerDownloadResponse::success() const {
  return success_;
}
inline void ServerDownloadResponse::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional double timestamp = 2;
inline bool ServerDownloadResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerDownloadResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerDownloadResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerDownloadResponse::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double ServerDownloadResponse::timestamp() const {
  return timestamp_;
}
inline void ServerDownloadResponse::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .pb.PlaceMapMsg map = 3;
inline bool ServerDownloadResponse::has_map() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerDownloadResponse::set_has_map() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerDownloadResponse::clear_has_map() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerDownloadResponse::clear_map() {
  if (map_ != NULL) map_->::pb::PlaceMapMsg::Clear();
  clear_has_map();
}
inline const ::pb::PlaceMapMsg& ServerDownloadResponse::map() const {
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::pb::PlaceMapMsg* ServerDownloadResponse::mutable_map() {
  set_has_map();
  if (map_ == NULL) map_ = new ::pb::PlaceMapMsg;
  return map_;
}
inline ::pb::PlaceMapMsg* ServerDownloadResponse::release_map() {
  clear_has_map();
  ::pb::PlaceMapMsg* temp = map_;
  map_ = NULL;
  return temp;
}
inline void ServerDownloadResponse::set_allocated_map(::pb::PlaceMapMsg* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::PlaceMatcherType>() {
  return ::pb::PlaceMatcherType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SlamServer_2eproto__INCLUDED
